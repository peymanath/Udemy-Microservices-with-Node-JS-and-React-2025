WEBVTT

00:00.990 --> 00:04.710
الان دیگه یه تعریف عملی از میکروسرویس داریم.

00:04.710 --> 00:08.130
آخر ویدیوی قبلی این دیاگرام رو دیدیم و شاید با خودت گفتی: خب، میکروسرویس که راحته!

00:08.130 --> 00:12.070
کافیه یه فیچر رو داخل یه سرویس قرار بدیم، تمومه.

00:12.090 --> 00:15.750
اما متأسفانه واقعیت کمی پیچیده‌تر از این حرفاست.

00:15.870 --> 00:18.840
وقتی با میکروسرویس‌ها کار می‌کنی، به چالش‌های جدی برمی‌خوری.

00:19.580 --> 00:23.840
توی این ویدیو می‌خوام یکی از همین چالش‌های بزرگ رو معرفی کنم.

00:23.840 --> 00:25.130
چالش اینه:

00:25.280 --> 00:29.630
مدیریت داده بین سرویس‌ها.

00:31.640 --> 00:33.980
منظورم از مدیریت داده اینه که چطور اطلاعات رو توی یک سرویس ذخیره می‌کنیم

00:34.640 --> 00:40.070
و چطور این اطلاعات رو بین سرویس‌های مختلف رد و بدل می‌کنیم.

00:44.450 --> 00:51.220
بذار همینجا صادقانه بگم: این یکی از سخت‌ترین مشکلات میکروسرویسه.

00:51.230 --> 00:55.490
یه مانع واقعاً جدی توی مسیر اجرای درست میکروسرویس‌هاست.

00:55.850 --> 01:01.100
خبر خوب اینه که قراره تمرکز اصلی ما توی این دوره دقیقاً همین مشکل باشه.

01:01.100 --> 01:01.790
کل دوره.

01:01.790 --> 01:06.200
تا آخر دوره، چندین راهکار مختلف برای مدیریت داده بین سرویس‌ها یاد می‌گیری.

01:08.650 --> 01:11.610
حالا بذار بیشتر توضیح بدم که چرا این موضوع انقدر مهمه.

01:11.620 --> 01:14.920
و چرا باید جدی گرفته بشه.

01:15.820 --> 01:20.260
خب، یه مقدمه کوچیک دربارهٔ میکروسرویس‌ها بگم.

01:20.260 --> 01:25.480
روش ذخیره و دسترسی به داده‌ها توی این مدل کمی عجیب و غریبه.

01:25.960 --> 01:29.980
عجیب از این نظر که با چیزی که توی اپلیکیشن‌های مونولیتیک دیدی فرق داره.

01:29.980 --> 01:31.750
متفاوته.

01:32.140 --> 01:36.820
تو دیاگرام‌های بعدی می‌خوایم ببینیم چطور داده رو ذخیره و بازیابی می‌کنیم توی معماری میکروسرویس.

01:39.490 --> 01:43.450
اول از همه: چطور داده ذخیره می‌کنیم؟

01:44.280 --> 01:46.770
یادت باشه دیاگرامی که قبلاً دیدیم رو...

01:46.770 --> 01:51.030
برای هر سرویس یه دیتابیس جداگانه داشتیم.

01:51.770 --> 01:57.290
یعنی توی معماری میکروسرویس، برای هر سرویس یک دیتابیس اختصاصی می‌سازیم.

01:57.290 --> 01:58.140
اگه نیاز داشته باشه.

01:58.160 --> 02:02.480
اگه سرویسی نیازی به دیتابیس نداشته باشه، بهش دیتابیس نمی‌دیم.

02:03.620 --> 02:07.220
ولی قاعده‌مون اینه: هر سرویس دیتابیس خودش رو داره.

02:07.640 --> 02:12.260
ممکنه عجیب به نظر برسه، ولی دلیل منطقی داره که الان بهت می‌گم.

02:12.260 --> 02:12.700
الان نه.

02:12.710 --> 02:15.890
اول اجازه بده نحوهٔ دسترسی به داده رو هم بگم.

02:15.890 --> 02:18.560
و اینم یه کم غیرعادیه.

02:19.620 --> 02:23.470
برای دسترسی به داده، نمی‌خوام بگم چطور باید انجامش بدیم.

02:23.490 --> 02:26.100
می‌خوام بگم چطور نباید انجامش بدیم!

02:26.100 --> 02:33.510
هیچ‌وقت نباید از یک سرویس به دیتابیس سرویس دیگه وصل بشیم.

02:33.780 --> 02:39.750
هیچ شرایطی نباید باعث بشه سرویس A مستقیم به دیتابیس سرویس B دسترسی بگیره.

02:39.750 --> 02:44.820
و دوباره، دلیلش رو در چند لحظه آینده بهت می‌گم.

02:45.740 --> 02:46.280
خب.

02:46.280 --> 02:51.800
پس تا الان، دو واقعیت عجیب اما مهم داریم.

02:52.010 --> 02:54.950
اول اینکه هر سرویس دیتابیس خودش رو داره، اگر نیاز باشه.

02:54.950 --> 02:59.590
و دوم اینکه سرویس‌ها نباید به دیتابیس سرویس‌های دیگه دست بزنن.

02:59.660 --> 03:01.730
حالا بیام بگم چرا.

03:01.760 --> 03:02.840
چرا این کارو می‌کنیم؟

03:02.840 --> 03:05.360
چون در ظاهر قوانین عجیبی هستن.

03:06.330 --> 03:07.860
ولی دلایل خوبی داریم.

03:08.280 --> 03:13.320
اول اینکه بدونی این روش دادن دیتابیس به هر سرویس خودش یه الگو یا pattern معروفه.

03:13.320 --> 03:14.160
اسمش هست:

03:14.190 --> 03:17.160
Database per service.

03:17.160 --> 03:20.370
یعنی برای هر سرویس، یک دیتابیس جداگانه.

03:21.010 --> 03:24.480
و حالا چند دلیل برای این کار. البته لیست کامل نیست.

03:24.810 --> 03:30.060
دلیل اول، و خیلی مهم، اینه که می‌خوایم هر سرویس مستقل از بقیه سرویس‌ها کار کنه.

03:30.060 --> 03:32.610
بدون وابستگی.

03:32.850 --> 03:37.590
بذار یه دیاگرام نشونت بدم که متوجه شی چرا این کار به استقلال کمک می‌کنه.

03:37.590 --> 03:38.730
و این دقیقاً کمک می‌کنه که سرویس‌ها مستقل بمونن.

03:40.330 --> 03:40.750
خب بریم سراغ مثال.

03:40.750 --> 03:47.380
فرض کن تمام سرویس‌هامون از یک دیتابیس مشترک استفاده کنن.

03:47.380 --> 03:48.880
مثلاً فقط یک دیتابیس داریم.

03:48.880 --> 03:50.740
اسمش رو بذاریم «دیتابیس همه‌چیز».

03:51.070 --> 03:56.230
مشکل اینجاست که اگه یه اتفاق بد برای این دیتابیس بیفته، همه سرویس‌هامون با هم کرش می‌کنن.

03:58.360 --> 04:02.560
مشکل بزرگ دیگه اینه که مقیاس‌پذیری این دیتابیس خیلی سخته.

04:02.560 --> 04:07.030
اگه همه سرویس‌ها از یک دیتابیس استفاده کنن، مجبوریم اون یک دیتابیس رو برای کل برنامه بزرگ کنیم.

04:07.030 --> 04:13.120
در حالی که خیلی راحت‌تره فقط دیتابیس سرویس‌هایی که نیاز به ظرفیت بیشتر دارن رو توسعه بدیم.

04:20.920 --> 04:22.450
سناریوی دیگه چیه؟

04:22.450 --> 04:27.880
فرض کن سرویس A داره به دیتابیس سرویس B وصل می‌شه.

04:28.660 --> 04:31.780
اگه مشکلی برای دیتابیس B پیش بیاد،

04:32.870 --> 04:37.730
سرویس A هم ممکنه خراب بشه، چون حالا به سرویس B وابسته شده.

04:37.730 --> 04:39.200
یعنی یه وابستگی بین A و B ایجاد کردیم.

04:39.590 --> 04:45.050
پس اگه یه درخواست وارد سرویس A بشه و فیچر A بخواد به دیتابیس B بره، ولی اون دیتابیس خرابه...

04:45.050 --> 04:48.710
سرویس A هم باهاش از کار می‌افته.

04:48.710 --> 04:53.930
و حالا به‌جای اینکه فقط سرویس B رو از دست بدیم، سرویس A هم رفته!

04:53.930 --> 05:01.400
ولی با جدا کردن دیتابیس برای هر سرویس و محدود کردنش به دیتابیس خودش، پایداری کل سیستم رو بالا می‌بریم.

05:07.730 --> 05:08.060
بریم سراغ دلیل بعدی.

05:08.060 --> 05:10.490
دلیل بعدی برای این الگو اینه که ساختار دیتابیس ممکنه ناگهانی تغییر کنه.

05:10.490 --> 05:15.440
یعنی همون اسکیمای دیتابیس ممکنه تغییر کنه.

05:15.440 --> 05:17.600
بذار یه مثال سریع بزنم.

05:17.990 --> 05:19.880
فرض کن سرویس A مستقیماً به دیتابیس B وصله.

05:19.910 --> 05:24.980
و البته این کار درست نیست، فقط داریم سناریو رو توضیح می‌دیم.

05:24.980 --> 05:25.430
خب...

05:25.430 --> 05:27.030
فرض کن فیچر A یه query اجرا می‌کنه

05:27.050 --> 05:29.510
مثلاً get user از دیتابیس B

05:29.720 --> 05:36.020
و دیتابیس B یه آبجکت برمی‌گردونه که یه property به نام `name` داره، مثلاً Jill.

05:41.690 --> 05:44.390
یعنی انتظار داریم مقدار `name` داشته باشیم.

05:45.020 --> 05:50.540
حالا فرض کن تیم مسئول سرویس B تصمیم بگیره ساختار دیتابیس رو تغییر بده.

05:50.540 --> 05:53.360
مثلاً به‌جای `name` از `firstName` استفاده کنن.

05:53.360 --> 05:58.940
و این تغییر رو به تیم سرویس A اطلاع ندن.

05:58.940 --> 06:00.590
یعنی بدون هماهنگی.

06:01.390 --> 06:07.420
اگه این اتفاق بیفته، دفعه بعد که سرویس A query می‌فرسته، به‌جای `name` مقدار `firstName` دریافت می‌کنه.

06:07.420 --> 06:10.570
ولی سرویس A برای `firstName` آماده نیست.

06:11.020 --> 06:16.210
و این باعث می‌شه مشکلاتی توی سرویس A شروع بشن.

06:16.210 --> 06:20.230
همه‌اش به‌خاطر اینه که به دیتابیس سرویس دیگه‌ای اتکا کرده بودیم.

06:21.040 --> 06:25.570
و اون دیتابیس بدون هماهنگی، ساختارش رو تغییر داده.

06:25.570 --> 06:29.380
پس اینم یکی دیگه از دلایل جداسازی دیتابیس‌هاست.

06:29.380 --> 06:36.160
چون اگر سرویس‌ها دیتابیس خودشون رو داشته باشن، این جور مشکلات هم به وجود نمیاد.

06:36.160 --> 06:39.430
دلیل آخر هم اینه:

06:41.120 --> 06:44.720
بعضی سرویس‌ها ممکنه با دیتابیس‌های خاصی بهتر کار کنن.

06:44.720 --> 06:48.100
مثلاً یه سرویس با MongoDB خیلی بهتر جواب می‌ده تا PostgreSQL.

06:48.110 --> 06:54.140
این انعطاف فقط با داشتن دیتابیس مجزا برای هر سرویس ممکنه.

06:57.350 --> 07:02.360
شاید اولش عجیب به نظر بیاد و بگی: واقعاً برای هر سرویس یه دیتابیس درست می‌کنیم؟

07:02.360 --> 07:04.520
ولی این واقعیه!

07:04.520 --> 07:07.720
همه تیم‌های حرفه‌ای دنیا دقیقاً همین کار رو می‌کنن.

07:07.730 --> 07:09.260
و جواب هم می‌گیرن.

07:09.260 --> 07:14.900
همه‌شون دارن از این الگو پیروی می‌کنن: یک دیتابیس برای هر سرویس.

07:14.900 --> 07:20.570
خب، حالا که این الگوی به ظاهر عجیب رو توضیح دادیم، هنوز نگفتیم چرا مدیریت داده بین سرویس‌ها انقدر چالشی هست.

07:21.150 --> 07:21.340
پس...

07:21.410 --> 07:25.850
الان یه توقف کوچیک می‌کنیم، و توی ویدیوی بعدی وارد اصل ماجرا می‌شیم.

07:25.850 --> 07:29.510
ببینیم دقیقاً چرا مدیریت داده انقدر پیچیده‌ست.

07:29.510 --> 07:30.710
بیشتر توضیح می‌دیم.

07:30.710 --> 07:34.520
پس همین‌جا یه مکث کوتاه داشته باش، و توی ویدیوی بعدی برمی‌گردیم به ادامه بحث.
