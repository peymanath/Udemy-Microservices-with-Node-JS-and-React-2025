WEBVTT

00:01.020 --> 00:05.340
توی ویدیوی قبلی، دلایلی برای داشتن یک دیتابیس برای هر سرویس بررسی کردیم.

00:05.510 --> 00:10.230
حالا توی این ویدیو، می‌خوایم دوباره برگردیم به همون بحث اصلی که گفتیم مدیریت داده بین سرویس‌ها چالش‌برانگیزه.

00:10.230 --> 00:14.340
می‌خوایم یه اپلیکیشن خیلی ساده رو بررسی کنیم که با الگوی "هر سرویس یک دیتابیس" ساخته می‌شه.

00:14.340 --> 00:20.790
و خیلی زود متوجه می‌شیم که این ساختار چطور می‌تونه مشکلات بزرگی در مدیریت داده ایجاد کنه.

00:20.790 --> 00:22.290
پس بریم یه مثال سریع ببینیم.

00:22.290 --> 00:24.510
و خیلی زود متوجه مشکل می‌شیم.

00:24.510 --> 00:27.990
با یه سری مشکلات بزرگ در مدیریت داده مواجه می‌شیم.

00:28.680 --> 00:32.760
برای درک بهتر این مثال، یه نگاهی به این دیاگرام بندازیم.

00:32.760 --> 00:35.550
فرض کن قراره این اپلیکیشن رو بسازیم.

00:35.730 --> 00:37.290
یه اپ خیلی ساده‌ست.

00:37.290 --> 00:42.420
یه فروشگاه اینترنتی که سه قابلیت اصلی داره.

00:42.750 --> 00:44.790
اول: امکان ثبت‌نام کاربر.

00:45.120 --> 00:49.950
دوم: نمایش محصولاتی که کاربر می‌تونه بخره، مثل کلاه، شلوار یا کفش.

00:50.250 --> 00:53.280
و سوم: امکان خرید اون محصولات.

00:53.940 --> 00:59.490
حالا فرض کن می‌خوایم این اپلیکیشن ساده رو با مدل مونولیتیک بسازیم.

00:59.520 --> 01:04.110
یادت باشه توی معماری مونولیت، کل کدمون توی یه کدبیسه و یه دیتابیس برای همه‌چیز داریم.

01:07.150 --> 01:10.100
اینم یه نگاه ساده به معماری مونولیتیکه.

01:10.120 --> 01:15.730
یه سرور مونولیتیک داریم با کدی برای ثبت‌نام، نمایش محصولات و خرید.

01:15.730 --> 01:16.510
همه چی تو یک جا.

01:17.200 --> 01:21.820
و خب، این سرور باید داده‌ها رو یه جایی ذخیره کنه، پس یه دیتابیس براش می‌سازیم.

01:21.820 --> 01:24.970
برای همهٔ این عملکردها از همون دیتابیس استفاده می‌کنیم.

01:25.360 --> 01:31.900
پس توی این دیتابیس، یه جدول برای کاربران داریم، یکی برای محصولات و یکی هم برای سفارش‌ها.

01:31.900 --> 01:35.110
تا اینجا خیلی ساده و قابل درکه.

01:35.890 --> 01:38.230
همه‌چی خوب پیش می‌ره.

01:38.590 --> 01:42.100
حالا بیایم یه فیچر جدید به مونولیت‌مون اضافه کنیم.

01:42.400 --> 01:48.160
مثلاً می‌خوایم بتونیم لیست محصولاتی که یه کاربر خاص سفارش داده رو نمایش بدیم.

01:50.240 --> 01:51.980
چطور باید این قابلیت رو پیاده کنیم؟

01:52.190 --> 01:56.930
اگه دقیق نگاه کنیم، به داده از هر سه جدول نیاز داریم.

01:56.930 --> 01:57.980
از همه‌شون.

01:58.250 --> 02:03.380
اول باید جدول کاربران رو بررسی کنیم تا مطمئن بشیم کاربر مورد نظر وجود داره.

02:03.380 --> 02:05.330
بعد می‌ریم سراغ جدول سفارش‌ها.

02:05.930 --> 02:11.660
سفارشی که اون کاربر ثبت کرده رو پیدا می‌کنیم.

02:12.460 --> 02:17.440
و توی سفارش، آیدی محصولاتی که خریده شده رو می‌بینیم.

02:18.520 --> 02:22.480
حالا اگه بخوایم اطلاعات محصول رو هم نشون بدیم، باید از جدول محصولات بخونیم.

02:22.480 --> 02:25.240
پس باید از هر سه جدول استفاده کنیم.

02:26.000 --> 02:30.680
یعنی برای این یه فیچر، نیاز به اطلاعات از سه منبع مختلف داریم.

02:30.680 --> 02:33.820
و توی معماری مونولیت، این کاملاً طبیعیه.

02:33.830 --> 02:35.450
هیچ مشکلی هم پیش نمیاد.

02:35.450 --> 02:36.920
همه چی روان و ساده‌ست.

02:37.930 --> 02:38.380
خب.

02:38.380 --> 02:44.080
حالا بیایم همین فروشگاه ساده رو با معماری میکروسرویس طراحی کنیم، ولی بدون اون فیچر آخر.

02:44.080 --> 02:45.010
همون بخش جدید.

02:45.010 --> 02:50.770
چطور می‌تونیم این سرور مونولیتیک رو به سه میکروسرویس جدا تبدیل کنیم؟

02:50.770 --> 02:52.420
یه مدلش این‌طوری می‌تونه باشه.

02:52.840 --> 02:55.360
برای هر سرویس یه نقش خاص تعریف می‌کنیم.

02:56.210 --> 03:00.440
مثلاً یه سرویس برای ثبت‌نام کاربر داریم.

03:00.680 --> 03:04.340
و طبق گفته قبلی، این سرویس دیتابیس مخصوص خودش رو داره.

03:04.430 --> 03:08.300
و اطلاعات کاربران ثبت‌نام‌شده توی اون ذخیره می‌شن.

03:04.430 --> 03:08.300
پس توی اون دیتابیس، اطلاعات همهٔ کاربرهایی که ثبت‌نام کردن ذخیره می‌شه.

03:08.960 --> 03:14.540
سرویس B مسئول مدیریت محصولات خواهد بود و سرویس C هم برای عملیات خرید یا ثبت سفارش.

03:14.540 --> 03:17.240
یعنی سرویس C قراره سفارش جدید ایجاد کنه.

03:17.480 --> 03:20.840
و طبیعتاً هر دوی سرویس‌های B و C هم دیتابیس مخصوص خودشون رو دارن.

03:22.540 --> 03:26.270
حالا بیایم دوباره فرض کنیم که می‌خوایم یه فیچر جدید اضافه کنیم.

03:26.290 --> 03:29.020
می‌خوایم یه سرویس چهارم اضافه کنیم.

03:29.020 --> 03:37.210
به اسم سرویس DX که کارش اینه که بتونه لیست سفارش‌های یه کاربر خاص رو نمایش بده (نه محصولات).

03:38.950 --> 03:44.110
اگه بخوایم از همون الگوی معماری مونولیت استفاده کنیم، ممکنه بگیم:

03:44.110 --> 03:49.180
خب، این سرویس DX می‌تونه به دیتابیس B و C وصل بشه.

03:50.020 --> 03:54.730
به دیتابیس محصول‌ها و سفارش‌ها متصل بشه.

03:55.390 --> 03:59.950
تا بتونه اطلاعات کاربر، سفارش ثبت‌شده و جزییات محصولات رو دریافت کنه.

03:59.950 --> 04:03.280
مثل کاری که توی معماری مونولیتیک می‌کردیم.

04:03.370 --> 04:10.420
اما همونطور که لحظاتی پیش گفتیم، توی دنیای میکروسرویس‌ها اجازه نداریم از دیتابیس سرویس دیگه استفاده کنیم.

04:14.950 --> 04:19.990
پس سؤال اینجاست: چطور باید سرویس DX رو بسازیم؟

04:20.020 --> 04:22.630
اصلاً چطور قراره این کار انجام بشه؟

04:22.840 --> 04:28.450
چطور می‌تونیم اطلاعات موردنیاز برای پیاده‌سازی این فیچر رو داشته باشیم بدون اینکه به دیتابیس‌های دیگه دسترسی بزنیم؟

04:30.160 --> 04:32.650
و این دقیقاً اصل ماجرای مشکله.

04:32.680 --> 04:39.040
این‌جاست که می‌فهمیم چرا مدیریت داده بین سرویس‌ها واقعاً پیچیده و چالش‌برانگیزه.

04:39.250 --> 04:42.640
البته مشکلات کوچیک دیگه‌ای هم هستن، ولی این اصلی‌ترین چالشه.

04:42.640 --> 04:43.270
همین موضوعه.

04:43.270 --> 04:47.260
سرویس‌ها اجازه ندارن به دیتابیس‌های همدیگه دست بزنن.

04:47.260 --> 04:52.510
پس وقتی می‌خوایم یه قابلیت جدید اضافه کنیم یا عملکرد یه سرویس رو تغییر بدیم، ولی به داده‌های قبلی نیاز داریم، چی‌کار باید بکنیم؟

04:56.020 --> 04:57.550
این خودش یه مشکل خیلی جدیه.

04:58.450 --> 04:59.800
پس همین‌جا یه توقف کوتاه می‌کنیم.

04:59.830 --> 05:01.030
و توی ویدیوی بعدی برمی‌گردیم.

05:01.030 --> 05:06.520
اونجا می‌خوام دو روش کلی رو معرفی کنم که باهاش بتونیم سرویس DX رو پیاده‌سازی کنیم.
