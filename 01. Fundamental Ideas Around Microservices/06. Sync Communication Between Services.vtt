WEBVTT

00:00.820 --> 00:05.350
توی ویدیوی قبلی، یه اپ فروشگاه اینترنتی ساده دیدیم و متوجه شدیم که اگه بخوایم

00:05.350 --> 00:10.810
یه سرویس جدید اضافه کنیم که به داده‌های سرویس‌های دیگه وابسته‌ست، اوضاع خیلی زود پیچیده می‌شه.

00:10.810 --> 00:12.700
به‌خصوص اگه بخوایم از الگوی هر سرویس یک دیتابیس پیروی کنیم،

00:12.700 --> 00:18.760
چون سرویس DX نمی‌تونه مستقیم به دیتابیس‌های دیگه دسترسی بگیره.

00:18.760 --> 00:21.370
نه به این، نه به اون، نه به هیچ‌کدوم.

00:21.670 --> 00:26.410
پس توی این ویدیو قراره دوتا استراتژی کلی برای حل این مشکل بررسی کنیم.

00:28.080 --> 00:33.000
این دوتا استراتژی کلی در واقع دربارهٔ نحوه ارتباط بین سرویس‌ها هستن.

00:33.000 --> 00:34.320
سرویس به سرویس.

00:34.560 --> 00:40.440
این دوتا استراتژی کلی به نام‌های ارتباط هم‌زمان (Synchronous یا Sync) و غیرهم‌زمان (Asynchronous یا Async) شناخته می‌شن.

00:41.100 --> 00:47.100
ولی دقت کن تو دنیای میکروسرویس‌ها این مفاهیم با تعریفشون توی جاوااسکریپت فرق دارن.

00:47.100 --> 00:48.690
کاملاً متفاوت.

00:48.690 --> 00:52.560
توی جاوااسکریپت Sync و Async یه معنی خاص دارن،

00:52.710 --> 00:58.140
اما اینجا، توی میکروسرویس‌ها، این مفاهیم چیز دیگه‌ای هستن و با اون فرق دارن.

00:58.470 --> 01:03.540
پس اول بریم تعریف ارتباط هم‌زمان (synchronous) رو بررسی کنیم.

01:05.210 --> 01:05.500
خب.

01:05.510 --> 01:10.340
توی دنیای ارتباط هم‌زمان، اگه بخوایم بین سرویس‌ها ارتباط برقرار کنیم،

01:10.340 --> 01:15.860
یکی از سرویس‌ها مستقیم به سرویس دیگه درخواست می‌فرسته.

01:16.190 --> 01:21.290
لزومی نداره که این درخواست حتماً HTTP باشه یا JSON رد و بدل کنه.

01:21.320 --> 01:28.130
فقط کافیه یه درخواست مستقیم باشه. هر نوعی که باشه. مستقیم از سرویس A به سرویس B برای دریافت اطلاعات.

01:31.760 --> 01:36.680
قبل از اینکه بریم سراغ تعریف async، اول یه مثال از ارتباط هم‌زمان ببینیم.

01:36.680 --> 01:38.000
خیلی واضح و کاربردی.

01:38.690 --> 01:39.020
خب.

01:39.020 --> 01:43.760
بیایم ایدهٔ ارتباط هم‌زمان رو روی همون اپ فروشگاه اینترنتی پیاده کنیم.

01:43.760 --> 01:44.750
مثالی که لحظاتی پیش دیدیم.

01:45.140 --> 01:51.530
پس دوباره فرض کن اپلیکیشنی داریم که شامل کاربران، محصولات و سفارش‌هاست.

01:51.710 --> 01:53.090
سفارش‌ها هم توی سرویس C هستن.

01:54.690 --> 01:59.430
اگه بخوایم از ارتباط هم‌زمان استفاده کنیم، فرض کنیم یه درخواست بیاد به سرویس

01:59.430 --> 01:59.790
DX.

01:59.790 --> 02:05.310
و درخواست این باشه که «تمام محصولاتی که کاربر با آیدی ۱ سفارش داده رو نشون بده».

02:05.880 --> 02:12.750
اولین کاری که سرویس DX می‌کنه اینه که یه درخواست مستقیم می‌فرسته به سرویس A.

02:12.750 --> 02:15.030
ممکنه این درخواست HTTP باشه،

02:15.060 --> 02:18.090
ممکنه JSON رد و بدل کنه، هر فرمتی باشه.

02:18.090 --> 02:22.050
مهم اینه که مستقیم از DX بره به A.

02:22.050 --> 02:25.140
سرویس DX بررسی می‌کنه که کاربر وجود داره یا نه.

02:25.290 --> 02:31.170
بعد اگه کاربر موجود بود، یه درخواست دیگه می‌فرسته به سرویس C برای پیدا کردن سفارش‌های اون کاربر.

02:36.860 --> 02:41.990
پاسخ می‌گیره و بعد درخواست سوم رو می‌فرسته به سرویس B برای دریافت اطلاعات دقیق محصولات.

02:44.120 --> 02:48.920
پس با این سه تا درخواست، سرویس DX تمام اطلاعات لازم رو داره برای پاسخ دادن.

02:48.920 --> 02:51.020
و پاسخ نهایی رو می‌فرسته.

02:51.960 --> 02:56.840
و نکته مهم اینه که توی هیچ‌کدوم از مراحل، سرویس DX به دیتابیس هیچ سرویس دیگه‌ای دست نزد.

02:56.850 --> 03:02.100
پس هنوز قانون مهممون یعنی «دیتابیس اختصاصی برای هر سرویس» نقض نشده.

03:03.000 --> 03:06.050
حالا بیایم مزایا و معایب این روش رو بررسی کنیم.

03:06.050 --> 03:07.850
هم مزیت داره، هم ایراد.

03:09.880 --> 03:14.740
از مزیت‌هاش اینه که ارتباط هم‌زمان خیلی ساده و قابل فهمه.

03:14.770 --> 03:18.580
با نگاه به همین دیاگرام، احتمالاً تا حد خوبی متوجه شدی جریان چطوریه.

03:19.810 --> 03:20.980
ما یه سرویس می‌سازیم،

03:21.010 --> 03:23.230
و این سرویس درخواست‌هایی به سرویس‌های دیگه می‌فرسته تا دیتا بگیره.

03:23.260 --> 03:24.100
همین!

03:25.130 --> 03:27.140
از نظر مفهومی، چیز پیچیده‌ای نیست.

03:27.620 --> 03:32.300
یه نکته مثبت دیگهٔ این روش اینه که سرویس D اصلاً نیازی به دیتابیس نداره.

03:32.300 --> 03:33.770
یعنی همین سرویس DX که اینجاست.

03:33.770 --> 03:37.440
لازم نیست براش دیتابیس تهیه، مدیریت یا پرداخت کنیم.

03:37.460 --> 03:44.150
چون تمام دیتاش رو از سرویس‌های دیگه می‌گیره که خودشون دیتابیس دارن، پس نیازی به دیتابیس نیست.

03:45.740 --> 03:49.580
ولی همون‌طور که گفتم، این روش معایب خیلی بزرگی هم داره.

03:49.940 --> 03:55.940
اولین مشکل اینه که این روش یه وابستگی بین سرویس D و اون سه‌تا سرویس دیگه ایجاد می‌کنه.

03:57.000 --> 04:01.860
یعنی اگه یکی از این سرویس‌ها به هر دلیلی از کار بیفته، مثلاً سرویس A،

04:01.860 --> 04:06.780
اون‌وقت سرویس D هم به مشکل می‌خوره و درست کار نمی‌کنه.

04:07.110 --> 04:10.290
در واقع، سرویس D هم به کل از کار می‌افته.

04:11.300 --> 04:17.240
یعنی اگه یه سرویس حیاتی توی سیستم دچار مشکل بشه، ممکنه کل اپ از کار بیفته.

04:20.590 --> 04:25.450
مشکل بعدی اینه که اگه هر کدوم از این درخواست‌های بین‌سرویسی fail بشن، کل درخواست fail می‌شه.

04:26.620 --> 04:30.160
دقیقاً مثل همون بحث از کار افتادن سرویس‌ها.

04:30.160 --> 04:33.160
اگه این درخواست اینجا fail بشه،

04:33.430 --> 04:38.140
ما نمی‌فهمیم که کاربر واقعاً وجود داره یا نه، پس احتمال زیاد یه خطا می‌دیم و می‌گیم:

04:38.140 --> 04:40.310
متاسفیم، خطا رخ داده. کمکی ازمون برنمیاد.

04:42.730 --> 04:48.370
اشکال بزرگ بعدی اینه که کل مدت اجرای درخواست برابر می‌شه با کندترین درخواست.

04:48.760 --> 04:54.100
فرض کن درخواست به سرویس A حدود ۱۰ میلی‌ثانیه طول بکشه.

04:54.460 --> 04:59.230
بعدی، که همه سفارش‌ها رو از سرویس C می‌گیره، ۱۰ میلی‌ثانیه دیگه زمان ببره.

05:00.380 --> 05:02.150
و در نهایت سرویس B اینجاست،

05:03.590 --> 05:04.100
و بنا به دلایلی،

05:04.100 --> 05:07.910
اون یکی ۲۰ ثانیه (!) طول بکشه.

05:08.580 --> 05:11.520
پس اون درخواست آخر ۲۰ ثانیه طول می‌کشه.

05:11.640 --> 05:18.080
و در نتیجه کل مدت اجرای درخواست هم ۲۰ ثانیه می‌شه.

05:18.090 --> 05:21.810
یعنی ما فقط به اندازه کندترین بخش، سرعت داریم.

05:23.560 --> 05:28.930
نکته آخر که شاید سخت‌تر فهمیده بشه اینه که این مدل می‌تونه وابستگی‌های تو در توی زیادی ایجاد کنه.

05:29.050 --> 05:31.570
که به‌مرور از کنترل خارج می‌شن.

05:32.250 --> 05:36.460
نکته‌ای که باید توی معماری میکروسرویس‌ها بهش توجه کرد (این دیاگرام جدید رو ببین)

05:36.760 --> 05:40.840
اینه که ما الزاماً نمی‌دونیم سرویس‌های دیگه توی خودشون دارن چی کار می‌کنن.

05:41.140 --> 05:45.850
یعنی ما که داریم سرویس DX رو می‌نویسیم، فقط می‌دونیم باید به A و B و C درخواست بفرستیم،

05:45.880 --> 05:49.680
ولی نمی‌دونیم که داخل اون‌ها چه خبره.

05:49.690 --> 05:54.850
شاید سرویس A برای اینکه درست کار کنه مجبور باشه خودش یه درخواست به سرویس Q بفرسته،

05:54.850 --> 06:00.670
و Q هم به نوبهٔ خودش به سرویس‌های Z و X وصل بشه.

06:00.820 --> 06:06.250
و این طوری برای پاسخ دادن به یه درخواست ساده مثل همین درخواست به سرویس DX،

06:06.250 --> 06:11.710
ممکنه پشت صحنه ده‌ها یا حتی صدها درخواست رد و بدل بشه.

06:12.040 --> 06:18.490
و اگه هر کدوم از این‌ها fail کنن، مثلاً این یا اون، کل درخواست شکست می‌خوره.

06:18.490 --> 06:18.970
تمام.

06:19.540 --> 06:23.980
و باز هم، سرعت کل سیستم برابر با کندترین درخواست می‌شه.

06:28.720 --> 06:32.350
پس در عمل، ارتباط هم‌زمان مزایایی داره،

06:33.190 --> 06:35.230
ولی از لحاظ اجرا، معایب بزرگی هم داره.

06:42.850 --> 06:43.150
خب،

06:43.150 --> 06:46.500
الان یه درک نسبتاً خوبی از ارتباط هم‌زمان داریم.

06:46.570 --> 06:48.240
می‌مونه ارتباط غیرهم‌زمان (Async).

06:48.250 --> 06:49.440
بذار یه توقف داشته باشیم.

06:49.450 --> 06:51.220
Async یکم پیچیده‌تره.

06:51.250 --> 06:53.500
الان می‌ریم سراغش که ببینیم چطور کار می‌کنه.
