WEBVTT

00:00.780 --> 00:04.620
خب دوستان، توی این ویدیو می‌خوایم به یه سؤال خیلی ساده جواب بدیم.

00:04.620 --> 00:06.810
میکروسرویس چیه؟

00:07.110 --> 00:12.270
برای اینکه بتونیم جواب این سؤال رو بدیم، اول یه مرور سریع می‌کنیم روی اینکه احتمالاً الان چطور سرور می‌سازید.

00:12.270 --> 00:13.080
در وضعیت فعلی.

00:13.230 --> 00:17.010
احتمال زیاد با معماری مونولیتیک آشنا هستید.

00:17.010 --> 00:21.240
این همون روشی هست که خیلی‌ها الان دارن سرورهاشون رو باهاش می‌سازن.

00:21.240 --> 00:26.760
یعنی کل کدی که برای پیاده‌سازی اپلیکیشن نیاز داریم توی یک کدبیس واحد قرار می‌گیره، و اون رو به‌صورت یکجا دیپلوی می‌کنیم.

00:26.760 --> 00:29.520
به عنوان یک واحد مستقل.

00:30.350 --> 00:35.240
فرض کنیم در یک سرور مونولیتیک، یه درخواست از مرورگر یا موبایل کاربر میاد،

00:35.240 --> 00:41.180
و وارد اپلیکیشن ما می‌شه، از یکسری middleware عبور می‌کنه،

00:41.570 --> 00:43.370
و بعدش مثلاً می‌ره سمت یه router خاص.

00:44.030 --> 00:48.890
اون router درخواست رو بررسی می‌کنه و تصمیم می‌گیره بفرسته به یک فیچر مشخص برای پردازش بیشتر.

00:48.890 --> 00:50.180
مثلاً می‌فرستتش به فیچر A.

00:50.390 --> 00:55.340
فیچر A ممکنه از دیتابیس اطلاعاتی بخونه یا بنویسه، یه پاسخ بسازه و اون رو برگردونه به کاربر.

01:02.040 --> 01:06.600
اگه بخوایم یه تعریف کلی از سرور مونولیتیک داشته باشیم، می‌تونیم این جمله رو بگیم:

01:06.600 --> 01:09.060
این جمله به خوبی خلاصه‌اش می‌کنه.

01:09.060 --> 01:14.520
مونولیت شامل همه‌ی مسیریابی‌ها، همه‌ی middlewareها، منطق تجاری (business logic)

01:14.520 --> 01:19.770
و کدهای دسترسی به دیتابیسه که برای پیاده‌سازی تمام فیچرهای اپلیکیشن نیاز داریم.

01:20.280 --> 01:22.290
این تعریف ما از مونولیت بود.

01:22.830 --> 01:24.600
حالا بریم سراغ این دیاگرام اینجا.

01:24.600 --> 01:30.450
قراره یکی دو تغییر توش بدیم، تا ببینیم که معماری میکروسرویس چطور کار می‌کنه.

01:30.450 --> 01:31.410
پایه‌اش همینه.

01:31.410 --> 01:34.620
و حالا تعریف ما از میکروسرویس اینطوریه:

01:34.620 --> 01:40.920
هر میکروسرویس شامل مسیریابی، middleware، منطق تجاری و دسترسی به دیتابیس مختص یک فیچر خاصه.

01:40.920 --> 01:45.990
یعنی تمام نیازمندی‌ها برای اجرای فقط یک فیچر خاص رو در خودش داره.

01:45.990 --> 01:47.880
و این همون تفاوت بزرگه.

01:48.330 --> 01:53.130
در مونولیت همه‌ی فیچرها توی یه جا نوشته شدن.

01:53.310 --> 01:57.900
در میکروسرویس، هر فیچر جداگانه و مستقل پیاده‌سازی می‌شه.

01:59.200 --> 02:02.290
حالا بیایم این مفاهیم رو بصورت بصری بررسی کنیم.

02:02.890 --> 02:03.220
خب.

02:03.220 --> 02:06.550
می‌دونم این دیاگرام یه کم شلوغه، ولی خیلی شبیه همون قبلیه.

02:06.550 --> 02:07.420
تقریباً همونه.

02:07.780 --> 02:13.360
توی این معماری میکروسرویس، ما اومدیم و فیچرها رو از هم جدا کردیم و برای هر کدوم یک سرویس جدا ساختیم.

02:13.360 --> 02:16.690
هر کدوم توی یک سرویس اختصاصی خودش قرار گرفته.

02:17.020 --> 02:23.020
نکته مهم اینجاست که هر سرویس کاملاً مستقل و خودبسنده‌ست.

02:23.000 --> 02:28.990
یعنی همین سرویسی که اینجا می‌بینیم، تمام کدی که برای اجرای فیچر A لازمه رو داره.

02:29.500 --> 02:31.930
مسیریاب مخصوص خودش رو داره، middleware خودش رو داره.

02:31.930 --> 02:37.120
و حتی دیتابیس مخصوص به خودش رو هم داره که ممکنه باعث تعجب بشه.

02:37.570 --> 02:43.540
مزیت این کار اینه که حتی اگه بقیه‌ی سرویس‌ها یا فیچرهای برنامه خراب بشن یا از کار بیفتن،

02:43.540 --> 02:49.390
این سرویس همچنان درست کار می‌کنه چون کاملاً مستقل طراحی شده.

02:49.390 --> 02:55.510
یعنی لازم نیست به سرویس دیگه‌ای وابسته باشه تا کار خودش رو انجام بده.

02:55.510 --> 02:57.640
خیلی هم خوب!

02:58.790 --> 02:59.270
خب.

02:59.270 --> 03:05.670
اینم یه معرفی اولیه و ساده از این‌که میکروسرویس چیه.

03:05.690 --> 03:11.510
فعلاً تعریف کاری ما اینه: هر میکروسرویس همه کدی رو شامل می‌شه که برای اجرای یک فیچر خاص لازمه.

03:11.510 --> 03:13.970
همین تعریف رو با خودمون نگه می‌داریم.

03:14.700 --> 03:18.290
حالا که تعریف اولیه‌مون رو داریم، یه توقف کوتاه می‌کنیم و خیلی زود ادامه می‌دیم.
