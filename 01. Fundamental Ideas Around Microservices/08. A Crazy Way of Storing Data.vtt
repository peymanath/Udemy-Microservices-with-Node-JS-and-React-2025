WEBVTT

00:00.750 --> 00:05.820
ما یاد گرفتیم چطور بین سرویس‌های مختلف با استفاده از ارتباط هم‌زمان و غیرهم‌زمان ارتباط برقرار کنیم.

00:05.970 --> 00:10.230
الان می‌خوایم یه روش دیگه برای استفاده از ارتباط غیرهم‌زمان رو بررسی کنیم.

00:10.490 --> 00:14.490
بذار همین حالا بهت بگم که این روش دوم یه مقداری شبیه الگوی پایگاه‌داده برای هر سرویسه،

00:14.490 --> 00:20.130
به این معنی که ممکنه این روش خیلی عجیب و ناکارآمد به نظر برسه.

00:20.130 --> 00:22.980
ولی فقط با من همراه باش.

00:22.980 --> 00:24.060
قول می‌دم برات جالبه.

00:24.060 --> 00:29.070
قراره یه مثال دقیق بررسی کنیم تا بفهمی چطور می‌تونیم با استفاده از ارتباط غیرهم‌زمان بین سرویس‌ها تعامل کنیم.

00:29.070 --> 00:32.910
قراره دوباره تمرکز کنیم روی ایده‌ی افزودن سرویس DX به اپلیکیشن فروشگاهی‌مون.

00:33.330 --> 00:39.360
اپلیکیشنی که الان فقط سه سرویس داره.

00:39.360 --> 00:41.430
محصول، سفارش و پرداخت.

00:42.850 --> 00:49.360
اولین کاری که می‌خوام انجام بدم اینه که هدف دقیق‌تری برای سرویس DX مشخص کنم.

00:49.360 --> 00:50.050
یعنی دقیقاً چی قراره انجام بده.

00:50.080 --> 00:53.770
الان فقط گفتیم که مثلاً می‌خوایم محصولاتی که یه کاربر خاص سفارش داده رو نشون بدیم.

00:53.770 --> 01:00.370
اما می‌خوام خیلی دقیق بگم که ورودی‌های این سرویس چیه و در پاسخ به هر درخواست چه خروجی‌ای باید بده.

01:00.370 --> 01:03.280
پس اینجا تعریف دقیق‌تر هدف این سرویس رو می‌گم.

01:03.550 --> 01:07.640
می‌خوام بگم وقتی شناسه‌ی یک کاربر رو داریم،

01:07.660 --> 01:14.110
باید عنوان و تصویر هر محصولی که اون کاربر تا حالا سفارش داده رو نمایش بدیم.

01:14.110 --> 01:15.790
این میشه هدف دقیق و مشخص سرویس DX.

01:15.820 --> 01:18.670
همین و بس.

01:18.670 --> 01:19.150
سرویس DX.

01:19.840 --> 01:25.690
حالا با این هدف، بیایم تصور کنیم که چطور می‌تونیم یه پایگاه‌داده طراحی کنیم که دقیقاً این نیاز رو برطرف کنه.

01:25.690 --> 01:26.860
فقط برای همین هدف خاص.

01:27.340 --> 01:33.190
ایده‌م اینه که یه پایگاه‌داده به سرویس DX اضافه کنیم که این ویژگی رو پیاده‌سازی کنه.

01:34.990 --> 01:37.160
فکر می‌کنم بتونیم یه دیتابیس اضافه کنیم.

01:37.180 --> 01:39.460
میتونه SQL باشه یا NoSQL، فرقی نمی‌کنه.

01:39.460 --> 01:42.670
فقط باید شامل دو مجموعه داده جداگانه باشه.

01:42.880 --> 01:47.020
یکی از این مجموعه‌ها لیستی از تمام کاربرانیه که توی اپلیکیشن ثبت‌نام کردن.

01:47.560 --> 01:49.870
ما اصلاً به ایمیل کاربر نیاز نداریم.

01:49.870 --> 01:51.220
نه اسمش، نه سنش، نه آدرسش.

01:51.220 --> 01:52.910
هیچ‌کدوم مهم نیستن.

01:52.930 --> 01:58.300
تنها چیزی که سرویس ما نیاز داره اینه که شناسه‌ی کاربر رو داشته باشه و محصولاتی که سفارش داده رو نشون بده.

01:58.300 --> 01:59.800
همین.

01:59.890 --> 02:05.890
پس داخل این مجموعه‌ی کاربران، فقط شناسه‌ی هر کسی که ثبت‌نام کرده رو ذخیره می‌کنیم.

02:05.890 --> 02:08.710
و بعد شناسه‌ی محصولاتی که اون کاربر تا حالا سفارش داده رو هم ذخیره می‌کنم.

02:09.160 --> 02:12.920
حالا برای اینکه عنوان و تصویر هر محصول رو بدونم،

02:12.940 --> 02:18.040
می‌تونم یه مجموعه جداگانه برای محصولات داشته باشم که توش شناسه محصول، عنوان و تصویرش ثبت شده باشه.

02:18.040 --> 02:18.790
همین‌قدر ساده.

02:18.970 --> 02:22.420
اگه بخوایم یه نمونه دیتای واقعی توی این ساختار بذاریم، ممکنه چیزی شبیه این باشه:

02:22.450 --> 02:29.440
مثلاً محصولی با شناسه ۵ و ۲۰ داشته باشم با عنوان‌هایی مثل شلوار و کفش،

02:29.440 --> 02:31.750
و تصاویری به اسم pants.jpeg و shoes.jpeg.

02:31.930 --> 02:34.300
تصاویر دقیقاً با اسم شلوار.جی‌پگ و کفش.جی‌پگ.

02:34.300 --> 02:35.230
خیلی ساده.

02:36.190 --> 02:40.910
حالا فرض کن یه کاربر بیاد و این دو محصول رو سفارش بده، مثلاً با شناسه ۱.

02:40.930 --> 02:42.280
این میشه شناسه کاربر ما.

02:43.090 --> 02:47.890
و اگه اون محصولات ۵ و ۲۰ رو سفارش داده باشه، می‌تونم اینا رو داخل یه آرایه ذخیره کنم.

02:49.510 --> 02:51.460
خب، حالا آیا می‌تونیم این نیاز رو برطرف کنیم؟

02:51.460 --> 02:54.030
آیا می‌تونیم این فیچر رو با این دیتابیس پیاده‌سازی کنیم؟

02:54.040 --> 02:55.550
بیایم دوباره مرحله به مرحله بررسیش کنیم.

02:55.570 --> 03:01.000
فرض کنیم شناسه کاربر رو داریم؛ مثلاً کاربری با شناسه ۱، حالا باید عنوان و تصویر هر محصولی که تا حالا سفارش داده رو نمایش بدیم.

03:01.000 --> 03:02.770
خب چیکار می‌کنیم؟

03:03.090 --> 03:08.560
می‌ریم سراغ مجموعه کاربران، کاربر با شناسه ۱ رو پیدا می‌کنیم و می‌بینیم که محصولاتی که سفارش داده، ۵ و ۲۰ هستن.

03:08.560 --> 03:10.540
بعد می‌ریم سراغ مجموعه محصولات.

03:10.990 --> 03:13.150
محصولات با شناسه ۵ و ۲۰ رو پیدا می‌کنیم،

03:13.150 --> 03:18.850
و عنوان و تصویر مربوط به هرکدوم رو می‌گیریم، و به درخواست ارسالی به سرویس DX پاسخ می‌دیم.

03:18.850 --> 03:22.120
خب به نظر می‌رسه این ساختار دقیقاً نیاز ما رو برطرف می‌کنه.

03:22.970 --> 03:24.870
پس اگه همچین دیتابیسی داشتیم،

03:24.890 --> 03:31.940
می‌تونستیم سرویس DX رو خیلی راحت پیاده‌سازی کنیم.

03:31.940 --> 03:35.450
و حتی مهم‌تر از اون، این سرویس کاملاً مستقل و بدون وابستگی بود.

03:35.870 --> 03:42.260
حالا سؤال اصلی اینه که چطور می‌تونیم این دیتابیس رو بسازیم و اطلاعات لازم رو داخلش وارد کنیم؟

03:42.260 --> 03:43.130
این خودش یه چالشه.

03:43.610 --> 03:45.320
یه چالش واقعی.

03:45.320 --> 03:49.580
چرا؟ چون اگه به ساختار کلی اپلیکیشن‌مون نگاه کنیم،

03:49.730 --> 03:54.380
سرویس DX هیچ‌وقت مستقیماً خبردار نمی‌شه که یه کاربر ثبت‌نام کرده،

03:55.420 --> 04:02.350
یا یه محصول ساخته شده، یا یه کاربر سفارشی ثبت کرده، چون این درخواست‌ها دارن به سرویس‌های A، B و C ارسال می‌شن.

04:02.350 --> 04:08.800
و خروجی اون سرویس‌ها هیچ‌وقت به سرویس DX منتقل نمی‌شن.

04:08.800 --> 04:09.220
دقیقاً همینطوره.

04:09.220 --> 04:09.620
DX هیچ‌وقت خبردار نمی‌شه.

04:09.730 --> 04:15.370
برای همین الان تقریباً غیرممکنه که اطلاعات لازم رو وارد دیتابیسی که تصور کردیم کنیم.

04:15.880 --> 04:17.080
و این همون مشکلیه که باید حلش کنیم.

04:17.080 --> 04:24.640
باید فکر کنیم که چطور می‌تونیم کاری کنیم سرویس‌های A، B و C به نحوی به سرویس DX اطلاع بدن

04:24.640 --> 04:28.900
وقتی که کاربری ثبت‌نام می‌کنه، محصولی ساخته می‌شه یا سفارشی ثبت می‌شه.

04:29.440 --> 04:34.840
و مهم‌تر اینکه، وقتی سرویس‌های A، B و C این اطلاعات رو ارسال می‌کنن، باید مطمئن بشیم

04:34.840 --> 04:41.290
که این ارتباط به صورتی باشه که اگه سرویس DX در دسترس نبود، سرویس A به مشکل نخوره.

04:41.920 --> 04:47.530
یعنی اگه بخوایم از ارتباط هم‌زمان استفاده کنیم که سرویس A به DX بگه فلان کاربر ثبت‌نام کرده،

04:47.530 --> 04:50.740
دوباره وابستگی ایجاد کردیم.

04:50.740 --> 04:55.000
و اگه اون درخواست به هر دلیلی شکست بخوره، ممکنه سرویس A هم کرش کنه.

04:55.630 --> 04:57.760
این تمام نیازهایی بود که باید در نظر بگیریم.

04:58.090 --> 04:59.410
پس چطور قراره این مشکل رو حل کنیم؟

04:59.500 --> 05:03.400
جوابش می‌رسه به استفاده از نوع خاصی از ارتباط غیرهم‌زمان.

05:03.790 --> 05:05.650
بیایم ببینیم این فرآیند چطور کار می‌کنه.

05:06.920 --> 05:12.560
می‌خوایم جریان کاری رو تصور کنیم که چطور اطلاعات وارد دیتابیسمون می‌شن.

05:12.950 --> 05:14.750
دقیقاً چه اتفاقی می‌افته.

05:15.200 --> 05:22.400
هر زمانی که درخواستی برای ساخت یک محصول، ثبت‌نام یک کاربر، یا ایجاد یک سفارش میاد،

05:22.400 --> 05:23.360
یعنی هر فعالیت مهمی،

05:23.420 --> 05:30.020
سرویس مربوطه باید به‌طور هم‌زمان یه رویداد منتشر کنه که توضیح بده چه اتفاقی افتاده.

05:30.020 --> 05:30.770
در لحظه.

05:31.100 --> 05:32.180
الان بهت نشون می‌دم منظورم چیه.

05:32.510 --> 05:37.730
اول فرض کن اپلیکیشن‌مون رو برای اولین بار اجرا کردیم و تصمیم گرفتیم که چند تا محصول جدید بسازیم.

05:37.730 --> 05:39.860
مثلاً یه درخواست به سرویس B ارسال می‌کنیم.

05:39.980 --> 05:42.170
برای ایجاد یه محصول.

05:42.990 --> 05:48.810
وقتی سرویس B این درخواست رو دریافت می‌کنه، می‌گه باشه، من این محصول رو می‌سازم

05:48.810 --> 05:54.210
و توی دیتابیس داخلی خودم ذخیره می‌کنم، به صورت هم‌زمان.

05:54.210 --> 05:56.070
و حالا نکته مهم اینجاست:

05:56.100 --> 06:03.540
سرویس B یه رویداد هم ارسال می‌کنه به سرویس باس ما (message broker)، و این رویداد ممکنه چیزی شبیه به این باشه:

06:03.540 --> 06:03.750
یه پیام ساده.

06:03.750 --> 06:05.730
بذار بزرگ‌ترش کنم که راحت‌تر ببینی.

06:07.760 --> 06:08.360
خب حالا ببین.

06:08.390 --> 06:09.020
سرویس B

06:09.020 --> 06:15.040
بعد از ذخیره‌سازی محصول جدید، یه رویداد منتشر می‌کنه با این مضمون: «اگه کسی براش مهمه، یه محصول جدید ساخته شده.»

06:15.050 --> 06:16.930
و اطلاعاتی از اون محصول هم ارسال می‌کنه.

06:16.940 --> 06:19.310
مثلاً شامل شناسه، عنوان و تصویر محصول.

06:19.340 --> 06:21.890
این پیام (event) وارد سیستم event broker ما می‌شه.

06:26.830 --> 06:28.940
اینجا سرویس باس یا event broker رو داریم.

06:30.110 --> 06:34.440
event bus این رویداد رو می‌گیره و به هر سرویسی که بهش علاقه‌منده ارسال می‌کنه.

06:34.460 --> 06:36.800
که در این مورد، سرویس DX خواهد بود.

06:37.960 --> 06:39.750
سرویس DX این رویداد رو دریافت می‌کنه.

06:39.760 --> 06:44.770
داخلش یه کدی داریم که این رویداد رو می‌خونه و می‌گه: اوکی، یه محصول ساخته شده با شناسه ۱، عنوان شلوار و تصویر pants.jpeg.

06:49.930 --> 06:54.760
سرویس DX این اطلاعات رو می‌گیره و توی جدول محصولات خودش ذخیره می‌کنه.

06:54.760 --> 06:56.500
یعنی ثبت می‌کنه ID: 1، عنوان: شلوار، تصویر: pants.jpeg

06:57.900 --> 07:00.270
همین شکلی: شناسه ۱، pants و تصویر pants.jpeg.

07:00.690 --> 07:01.470
خیلی ساده.

07:02.890 --> 07:05.900
و اینطوری اطلاعات وارد دیتابیس ما می‌شن.

07:05.920 --> 07:08.650
ما وابسته به سرویس‌های دیگه هستیم که هر وقت اتفاقی افتاد رویداد منتشر کنن.

07:08.680 --> 07:12.580
یعنی سرویس‌های A، B و C هر وقت چیزی مهمی اتفاق افتاد، یه event می‌فرستن.

07:13.510 --> 07:17.500
حالا همین روال رو برای وقتی کاربر ثبت‌نام می‌کنه هم تصور کنیم.

07:17.500 --> 07:18.340
ببین چی می‌شه.

07:19.030 --> 07:22.000
فرض کن یه مدت بعد از ساختن محصول، کاربری ثبت‌نام می‌کنه.

07:23.210 --> 07:25.130
من هم اصطلاحات رو به‌روزرسانی می‌کنم.

07:26.740 --> 07:27.400
بریم سراغش.

07:29.420 --> 07:33.260
پس مثلاً یه کاربر جدید وارد اپلیکیشن می‌شه و ثبت‌نام می‌کنه.

07:34.560 --> 07:36.180
درخواستی برای ثبت‌نام میاد.

07:37.960 --> 07:40.230
که می‌ره به سرویس A.

07:40.240 --> 07:46.120
سرویس A کاربر رو توی مجموعه کاربران خودش ذخیره می‌کنه و یه رویداد منتشر می‌کنه به سمت event bus.

07:46.120 --> 07:51.940
مثلاً با نوع user_created و داده‌ای که فقط شامل شناسه اون کاربره.

07:53.120 --> 07:56.660
دوباره این رویداد می‌ره سمت event bus.

07:56.930 --> 07:59.990
و event bus این رویداد رو می‌فرسته برای سرویس DX.

08:00.900 --> 08:04.650
سرویس DX رویداد رو می‌گیره و پردازش می‌کنه.

08:06.530 --> 08:07.280
داخل سرویس DX

08:07.280 --> 08:09.690
یه کدی داریم که می‌گه: اوکی، یه کاربر جدید ایجاد شده.

08:09.710 --> 08:11.890
میایم اون رو به مجموعه کاربران خودمون اضافه می‌کنیم.

08:11.900 --> 08:14.930
مثلاً با شناسه ۱، و چون هنوز محصولی سفارش نداده، یه آرایه خالی از شناسه محصولات براش ذخیره می‌کنیم.

08:15.020 --> 08:20.840
فقط ID کاربر و لیستی خالی از سفارش‌ها.

08:20.840 --> 08:22.820
الان دیگه می‌دونی روند کار چطوره.

08:23.300 --> 08:25.340
فقط یه قدم دیگه مونده.

08:25.550 --> 08:28.280
فرض کنیم حالا یه سفارش برای محصول ثبت می‌شه.

08:29.350 --> 08:32.620
این درخواست می‌ره به سرویس C.

08:35.360 --> 08:36.660
وارد سرویس C می‌شه.

08:36.680 --> 08:37.250
خب حالا چی؟

08:38.100 --> 08:41.340
برای صرفه‌جویی در زمان، اصطلاحات رو دیگه عوض نمی‌کنم.

08:41.370 --> 08:45.780
ولی فرض کن این درخواست وارد سرویس C شده، سرویس C یه سفارش جدید ایجاد می‌کنه تو دیتابیس خودش و بعد یه event منتشر می‌کنه.

08:50.610 --> 08:55.800
این event مثلاً می‌تونه order_created باشه و اطلاعاتی مثل شناسه کاربر و شناسه محصول هم همراهش باشه.

08:55.800 --> 09:01.620
یعنی دقیقاً بگه کدوم کاربر، کدوم محصول رو سفارش داده.

09:02.700 --> 09:09.090
بعد این رویداد به سمت event bus می‌ره و از اونجا به سرویس DX ارسال می‌شه.

09:11.530 --> 09:12.370
همینجا توی DX.

09:13.130 --> 09:16.130
سرویس می‌گه: اوه، یه سفارش ایجاد شده.

09:16.160 --> 09:22.160
به نظر می‌رسه کاربر با شناسه ۱ محصولی با شناسه ۱ رو سفارش داده، پس آرایه شناسه محصولات اون کاربر رو به‌روزرسانی می‌کنیم.

09:22.160 --> 09:24.530
عدد ۱ رو بهش اضافه می‌کنیم و تموم.

09:24.530 --> 09:31.280
حالا دیتابیس ما کامل پر شده و سرویس DX می‌تونه فوراً و خیلی سریع پاسخ بده که:

09:31.280 --> 09:34.970
کاربر با شناسه ۱ چه محصولاتی سفارش داده؟

09:36.030 --> 09:36.540
خب،

09:36.540 --> 09:41.630
این بود ارتباط غیرهم‌زمان، نوع دومش که بررسی کردیم.

09:41.640 --> 09:45.090
و چون این ویدیو خیلی طولانی شد، اینجا مکث می‌کنیم،

09:45.090 --> 09:46.620
و تو ویدیوی بعدی یه خلاصه می‌گیم

09:46.650 --> 09:48.420
و مزایا و معایب این روش رو بررسی می‌کنیم.