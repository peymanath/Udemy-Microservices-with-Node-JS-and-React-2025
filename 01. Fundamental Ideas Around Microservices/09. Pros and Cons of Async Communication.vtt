WEBVTT

00:01.140 --> 00:04.700
توی ویدیوی قبلی، روش دوم از ارتباط غیرهم‌زمان رو بررسی کردیم.

00:04.700 --> 00:06.250
که انصافاً خیلی عجیب و غریب بود!

00:06.270 --> 00:10.980
یادت باشه اول ویدیو گفتم که این الگو ممکنه خیلی عجیب و ناکارآمد به نظر برسه.

00:10.980 --> 00:12.060
و دقیقاً هم همین‌طور بود.

00:12.390 --> 00:17.430
ولی قبل از اینکه کامل این روش رو کنار بذاریم، بیایم یه نگاه به مزایا و معایبش بندازیم

00:17.430 --> 00:20.580
تا ببینیم واقعاً ارزش امتحان کردن داره یا نه.

00:21.310 --> 00:21.550
خب،

00:21.550 --> 00:22.930
بریم سراغ مزایا و معایب.

00:23.410 --> 00:29.620
از مزایای این روش اینه که سرویس DX هیچ وابستگی مستقیمی به سرویس‌های دیگه نداره.

00:30.220 --> 00:35.230
وقتی می‌گم هیچ وابستگی، منظورم اینه که موقعی که یه درخواست به سرویس DX می‌رسه، آیا می‌تونه خودش به تنهایی پاسخ بده یا نه؟

00:35.230 --> 00:38.110
و جواب اینه: بله، کاملاً می‌تونه.

00:39.350 --> 00:43.230
سرویس DX می‌تونه بفهمه یه کاربر چه محصولاتی سفارش داده، بدون اینکه نیاز باشه به سرویس دیگه‌ای وصل بشه.

00:43.250 --> 00:44.300
یعنی مستقل کار می‌کنه.

00:44.330 --> 00:50.060
هیچ نیازی به پاسخ فوری از سرویس‌های A، B یا C نداره.

00:50.090 --> 00:54.710
درسته که برای پر کردن دیتابیس خودش به اطلاعات از اون سرویس‌ها نیاز داره،

00:54.710 --> 00:57.260
ولی اینا وابستگی‌های غیرمستقیم هستن.

00:57.410 --> 00:59.600
حتی اگه سرویس‌های A، B و C قطع بشن،

01:00.350 --> 01:01.970
و کلاً از بین برن،

01:02.000 --> 01:07.180
سرویس DX همچنان ۱۰۰٪ درست و بدون مشکل کار می‌کنه.

01:07.190 --> 01:11.060
پس می‌تونیم بگیم که سرویس DX عملاً هیچ وابستگی به بقیه نداره.

01:11.900 --> 01:17.510
مزیت بزرگ دیگه اینه که سرویس DX نسبت به دو روش قبلی که بررسی کردیم خیلی سریع‌تره.

01:17.510 --> 01:18.700
واقعاً سریع‌تر.

01:18.710 --> 01:23.750
چرا؟ چون سرویس DX همه‌ی اطلاعات مربوط به سفارش‌های کاربر رو تو دیتابیس خودش داره.

01:23.750 --> 01:25.580
و فوراً بهشون دسترسی داره.

01:25.580 --> 01:30.470
مستقیم می‌ره سراغ دیتابیس، دیتا رو می‌گیره و فوراً به درخواست جواب می‌ده.

01:30.530 --> 01:35.270
و لازم نیست هیچ درخواست مستقیمی به سرویس‌های A یا B یا C بفرسته.

01:36.910 --> 01:36.990
خب،

01:37.000 --> 01:38.140
حالا بریم سراغ معایب.

01:38.170 --> 01:40.910
عیب بزرگ این روش تکرار داده‌ست.

01:40.930 --> 01:45.670
اینجا داریم اطلاعات رو بین سرویس‌ها کپی می‌کنیم و تکراری ذخیره می‌کنیم.

01:46.120 --> 01:52.240
یادت باشه، اصل قضیه این بود که وقتی درخواستی برای ثبت‌نام کاربر، ساخت محصول یا ثبت سفارش میاد،

01:52.660 --> 01:58.420
اون سرویس اطلاعات رو داخل دیتابیس خودش ذخیره می‌کنه،

01:58.420 --> 02:01.770
چه مربوط به سفارش باشه، چه محصول، چه کاربر.

02:01.780 --> 02:06.070
و بعد اون اطلاعات مربوط به کاربر، محصول یا سفارش رو برداشتیم و توی دیتابیس دوم هم ذخیره کردیم.

02:06.070 --> 02:08.890
البته کل رکورد رو دقیقاً کپی نکردیم.

02:09.310 --> 02:12.160
برای همین هم قبلاً تأکید کردیم که نیازها رو دقیق مشخص کنیم.

02:12.190 --> 02:17.830
مثلاً گفتیم فقط عنوان و تصویر محصول برای ما مهمه.

02:17.830 --> 02:19.540
محصول ممکنه اطلاعات دیگه‌ای مثل قیمت یا نظرات کاربرا هم داشته باشه.

02:19.540 --> 02:24.430
ولی ما فقط عنوان و تصویر رو ذخیره کردیم.

02:24.430 --> 02:27.100
یعنی به‌صورت صددرصدی داده‌ها تکرار نشدن،

02:27.100 --> 02:32.950
اما خب قطعاً یه مقداری تکرار دیتا داریم.

02:33.280 --> 02:38.170
ممکنه فکر کنی این خیلی بده چون داریم هزینه بیشتری برای ذخیره‌سازی می‌دیم،

02:38.410 --> 02:44.230
اما اگه بیای وسط بحث و شکایت کنی بابت هزینه‌ی ذخیره‌سازی، شدیداً باهات برخورد می‌کنم!

02:44.230 --> 02:46.180
الان می‌گم چرا.

02:46.180 --> 02:47.440
بذار همین حالا ذهنت رو راحت کنم.

02:47.440 --> 02:51.070
الان یه پرانتز باز کنیم و سریع بررسی کنیم که واقعاً هزینه چقدره؟

02:51.400 --> 02:52.660
یه تحقیق کوچیک انجام دادم.

02:53.740 --> 02:59.260
الان که دارم این ویدیو رو ضبط می‌کنم، برای اینکه ۱ گیگابایت فضای ذخیره‌سازی بگیری با استفاده از Azure یا Google Cloud یا AWS MySQL،

02:59.260 --> 03:07.450
قیمت به‌طور میانگین حدود ۱۱.۵ سنت توی Azure، ۱۷ سنت توی Google و ۱۱.۵ سنت توی AWS هست برای هر گیگابایت در ماه.

03:07.600 --> 03:11.490
یعنی حدود ۱۱ تا ۱۷ سنت باید بدی برای یه گیگابایت فضای یک‌ماهه.

03:11.500 --> 03:16.750
پس این یه معیار کلیه برای هزینه‌ی ذخیره‌سازی بین ارائه‌دهنده‌های معروف.

03:17.230 --> 03:18.400
بعدش کنجکاو شدم بدونم...

03:18.400 --> 03:23.290
ذخیره‌ی اطلاعات مربوط به یه محصول چقدر جا می‌گیره واقعاً؟

03:23.740 --> 03:29.080
توی این باکس آبی پایین، یه عالمه متن ریز می‌بینی.

03:29.530 --> 03:35.050
اون خروجی API از سایت آمازون هست که اطلاعات کامل یه محصول واقعی رو برمی‌گردونه.

03:35.170 --> 03:41.860
این همون چیزیه که آمازون برای یه محصول واقعی نشون می‌ده، پس اطلاعات کاملاً واقعیه.

03:41.860 --> 03:43.390
دیتای واقعاً کاربردیه.

03:43.390 --> 03:48.490
حالا می‌خواستم بدونم اندازه این دیتا چقدره؟ یعنی اطلاعات مربوط به فقط یه محصول.

03:48.490 --> 03:51.280
همونطور که می‌بینی، این دیتا به فرمت JSON هست.

03:52.430 --> 03:56.410
یعنی شامل کلی key، کوتیشن، براکت و غیره هست.

03:56.420 --> 03:58.400
چیزهایی که معمولاً توی دیتابیس ذخیره نمی‌شن.

03:58.430 --> 04:00.290
ولی گفتم عیب نداره، بیایم بدترین حالت رو بررسی کنیم.

04:00.290 --> 04:06.800
یعنی این JSON رو همون‌طوری که هست حساب کنیم ببینیم چقدر فضا می‌گیره.

04:06.800 --> 04:09.290
و نتیجه این شد که این دیتا حدود ۱۲۰۰ بایت فضا می‌گیره.

04:18.020 --> 04:19.370
یه محاسبه ساده انجام دادم.

04:19.370 --> 04:22.070
گفتم خب، حدوداً ۱۲۰۰ بایت داده داریم.

04:22.580 --> 04:27.350
اگه این مقدار رو به گیگابایت تبدیل کنیم و ضرب کنیم در ۱.۵ سنت برای هر گیگ در ماه،

04:27.350 --> 04:33.740
و بعد محاسبه کنیم که ذخیره‌سازی صد میلیون محصول با این حجم توی یه دیتابیس چقدر هزینه داره،

04:33.740 --> 04:34.730
جوابش می‌شه...

04:34.730 --> 04:43.550
فقط ۱۴ دلار — صد میلیون محصول، فقط ۱۴ دلار! حالا واقعاً نمی‌تونیم ۱۴ دلار بدیم برای ذخیره یه مقدار دیتای اضافه توی یه اپلیکیشن مایکروسرویس؟

04:43.550 --> 04:45.200
جواب قطعاً بله‌ست.

04:45.200 --> 04:48.710
هزینه‌ی ذخیره‌سازی اصلاً جزو معایب محسوب نمی‌شه، چون تو دنیای امروز تقریباً مجانیه.

04:49.100 --> 04:55.790
برای من، مشکل تکرار داده فقط از نظر احتمال قدیمی شدن دیتا توی زمانه — که اونم بعداً دربارش صحبت می‌کنیم.

04:56.590 --> 05:02.410
ولی از نظر قیمت؟ نه، اصلاً جای نگرانی نداره. نقطه، تمام.

05:03.940 --> 05:08.080
خب حالا بریم سراغ آخرین مورد از معایب این روش.

05:08.110 --> 05:08.800
و اون چیه؟

05:09.920 --> 05:10.220
سخته!

05:10.220 --> 05:11.150
سخت برای درک.

05:11.150 --> 05:12.290
و کاملاً هم درسته.

05:12.320 --> 05:13.310
واقعاً سخته.

05:13.310 --> 05:15.020
کل این ایده که همه سرویس‌ها رویداد منتشر کنن،

05:15.200 --> 05:20.870
و بعد سرویس‌های دیگه گوش بدن و منتظر باشن — این کار کلی بار اضافی به همراه داره.

05:20.870 --> 05:21.770
کد اضافی،

05:21.770 --> 05:25.220
پیچیدگی اضافی، درک سخت‌تر برای تیم توسعه.

05:25.490 --> 05:28.250
پس بله، این روش قطعاً معایبی داره.

05:28.250 --> 05:35.300
ولی وقتی صحبت از عملکرد بهتر و در دسترس بودن دائمی برای کاربره، این نوع ارتباط غیرهم‌زمان بهترین گزینه‌ست.

05:35.300 --> 05:37.490
بدون شک، راه درست همینه.

05:37.490 --> 05:39.140
این دقیقاً همون مسیریه که باید رفت.

05:40.200 --> 05:45.080
و همونطور که حدس زدی، توی این دوره تمرکز اصلی ما هم روی همین نوع از ارتباط غیرهم‌زمانه.

05:45.080 --> 05:45.980
دقیقاً همین.

05:46.160 --> 05:50.330
قراره کلی سرویس مختلف بسازیم که درخواست ورودی دریافت می‌کنن.

05:50.900 --> 05:54.950
سرویس‌ها اون درخواست رو پردازش می‌کنن و اگه تغییری در دیتا ایجاد کنن، یه event منتشر می‌کنن.

05:54.950 --> 05:56.600
یه رویداد مستقل.

05:56.930 --> 06:02.330
سرویس‌های دیگه گوش می‌دن و با دریافت این رویدادها دیتابیس‌هایی شبیه اونچه دیدیم رو پر می‌کنن

06:02.330 --> 06:05.960
تا بتونن به سوالات خاص و مشخص خیلی سریع پاسخ بدن.

06:07.140 --> 06:07.560
خب،

06:07.560 --> 06:12.000
الان که یه دید کلی نسبت به این نوع ارتباط async پیدا کردیم، همین‌جا مکث می‌کنیم.

06:12.000 --> 06:15.180
از ویدیوی بعدی شروع می‌کنیم به ساخت اولین پروژه‌مون.