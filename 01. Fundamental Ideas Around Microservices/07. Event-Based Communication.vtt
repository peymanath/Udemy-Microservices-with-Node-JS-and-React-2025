WEBVTT

00:01.340 --> 00:06.380
توی این ویدیو می‌خوایم ارتباط بین سرویس‌ها رو با استفاده از مدل ارتباط غیرهم‌زمان (async) بررسی کنیم.

00:06.380 --> 00:07.070
مدل async.

00:07.280 --> 00:11.750
قراره به دو روش مختلف برای ارتباط async نگاه بندازیم.

00:11.780 --> 00:16.330
اولی که توی همین ویدیو می‌بینیم، خیلی ایده‌آل نیست و ایرادات جدی داره.

00:16.340 --> 00:18.310
ولی لازمه که باهاش آشنا بشی.

00:18.320 --> 00:23.030
توی ویدیوی بعدی روش دوم ارتباط async رو بررسی می‌کنیم که بهتره.

00:23.030 --> 00:24.950
پس بریم سراغ روش اول.

00:24.980 --> 00:28.490
روش اول خیلی عالی نیست، ولی دونستنش ضروریه.

00:28.970 --> 00:29.200
خب.

00:29.300 --> 00:34.160
ایده کلی ارتباط غیرهم‌زمان اینه که ما یه چیزی رو به کل سیستممون اضافه می‌کنیم

00:34.160 --> 00:39.410
که تمام سرویس‌ها بتونن بهش دسترسی داشته باشن، بهش می‌گیم event bus.

00:41.270 --> 00:47.300
هدف این event bus اینه که اعلان‌ها یا eventهایی که از سرویس‌های مختلف منتشر می‌شن رو مدیریت کنه.

00:47.300 --> 00:48.140
ایونت‌ها یا اعلان‌ها.

00:48.380 --> 00:54.590
این اعلان‌ها در واقع آبجکت‌هایی هستن، مثل یادداشت‌های کوچیکی که می‌گن چه اتفاقی افتاده

00:54.590 --> 01:00.410
یا باید چه اتفاقی بیفته توی اپلیکیشن کلی ما.

01:01.630 --> 01:06.160
هر سرویس به این event bus وصل می‌شه و وقتی وصل شد،

01:06.190 --> 01:10.780
می‌تونه event بفرسته یا event دریافت کنه.

01:11.320 --> 01:15.700
یه نکته مهم اینه که الان همه سرویس‌ها به یه نقطهٔ مشترک وصل شدن،

01:15.700 --> 01:19.140
یعنی ما یه نقطهٔ واحد خرابی داریم (Single Point of Failure).

01:19.150 --> 01:23.560
واسه همین وقتی از event bus استفاده می‌کنیم، کلی تلاش می‌کنیم که مقاوم باشه،

01:23.560 --> 01:29.140
وگرنه اگه داون بشه، ارتباط همه سرویس‌ها مختل می‌شه.

01:23.560 --> 01:30.340
این سیستم باید پایداری بالایی داشته باشه تا مدام خراب نشه و ارتباط بین سرویس‌ها رو مختل نکنه.

01:30.760 --> 01:35.980
حالا بیایم یه مثال واقعی ببینیم که چطور با استفاده از event bus و ارسال event

01:35.980 --> 01:37.390
می‌تونیم مشکل سرویس DX رو حل کنیم.

01:38.990 --> 01:39.440
خب.

01:39.440 --> 01:44.300
فرض کن که سرویس DX یه درخواست دریافت می‌کنه که لیست تمام محصولات سفارش داده شده توسط یه کاربر خاص رو نشون بده.

01:44.300 --> 01:46.220
یعنی همون داستان قبلی.

01:46.730 --> 01:51.770
برای انجام این کار، سرویس DX نیاز به اطلاعاتی از سرویس‌های A و B و C داره.

01:51.770 --> 01:55.760
پس اولین کاری که می‌کنه اینه که یه event منتشر می‌کنه.

01:56.180 --> 01:58.010
این یه نمونهٔ event ـه.

01:58.010 --> 02:03.710
یه event معمولاً یه نوع داره (type) که مشخص می‌کنه چه اتفاقی افتاده، و ممکنه یه سری داده هم داشته باشه.

02:03.710 --> 02:07.130
یه سری اطلاعات یا داده‌های مرتبط هم می‌تونه همراه این ایونت باشه.

02:07.250 --> 02:11.780
تو این مثال، ممکنه نوع ایونت چیزی مثل "user query" باشه و داده‌ش آی‌دی کاربری باشه که می‌خوایم پیداش کنیم.

02:11.780 --> 02:14.150
هدفمون اینه که اول مطمئن بشیم این کاربر واقعاً وجود داره.

02:14.150 --> 02:18.620
پس این ایونت ارسال می‌شه به سمت event bus.

02:18.620 --> 02:21.560
event bus می‌تونه ایونت‌های ورودی رو بگیره و به سرویس‌هایی که می‌تونن اون رو پردازش کنن بفرسته.

02:22.900 --> 02:26.230
تو اینجا، می‌تونیم event bus رو طوری پیکربندی کنیم که یه کپی از ایونت رو به سرویس A بفرسته.

02:26.590 --> 02:32.230
پس تصور می‌کنیم که این ایونت به این شکل می‌ره به سمت سرویس A.

02:32.230 --> 02:34.150
توی سرویس A، یه کدی داریم که با دریافت ایونت اجرا می‌شه.

02:34.330 --> 02:40.900
سرویس A متوجه می‌شه که قراره اطلاعات یک کاربر واکشی بشه.

02:40.900 --> 02:45.460
پس می‌ره اطلاعات اون کاربر رو (مثلاً با آی‌دی 1) از دیتابیسش می‌خونه.

02:46.230 --> 02:47.130
حالا چطوری به DX جواب بده؟

02:47.130 --> 02:51.270
سرویس A می‌تونه یه ایونت جدید منتشر کنه روی event bus.

02:51.660 --> 02:53.810
مثلاً ایونتی با نوع "user query result".

02:53.820 --> 02:57.120
و داده‌هایی مثل آی‌دی و اسم "Jill" و اطلاعات دیگه.

02:57.480 --> 03:03.030
این ایونت وارد event bus می‌شه و event bus طوری تنظیم شده که اون رو بفرسته برای سرویس DX.

03:03.030 --> 03:05.880
پس این ایونت به سرویس DX می‌رسه.

03:06.030 --> 03:12.870
توی سرویس DX هم کدی داریم که این نوع ایونت رو بگیره و روش پردازش انجام بده.

03:13.680 --> 03:20.040
و بعد می‌تونیم همین روند رو برای گرفتن سفارش‌های کاربر از سرویس C و گرفتن اطلاعات محصولات از سرویس B تکرار کنیم.

03:20.040 --> 03:22.080
تا تمام داده‌های لازم به دست بیاد.

03:22.080 --> 03:26.460
مثلاً آی‌دی کاربر، اسمش که "Jill" هست و هر اطلاعات دیگه‌ای که لازم باشه.

03:27.120 --> 03:31.380
این ایونت وارد event bus می‌شه و ما می‌تونیم event bus رو طوری پیکربندی کنیم که ایونت‌هایی با نوع "user query result"

03:31.380 --> 03:37.380
رو به صورت خودکار برای سرویس DX ارسال کنه.

03:37.380 --> 03:38.490
پس این ایونت به سرویس DX می‌رسه.

03:38.850 --> 03:41.250
توی سرویس DX هم یه کدی داریم که این نوع ایونت رو می‌گیره و پردازشش می‌کنه.

03:42.840 --> 03:48.930
بعدش می‌تونی تصور کنی که همین روند رو برای واکشی لیست سفارش‌هایی که این کاربر ثبت کرده هم تکرار می‌کنیم،

03:48.930 --> 03:49.500
و همچنین گرفتن اطلاعات محصولات مربوط به اون سفارش‌ها از سرویس B.

03:50.070 --> 03:54.420
می‌تونی تصور کنی که همین روند رو دوباره تکرار می‌کنیم برای اینکه ببینیم این کاربر چه سفارش‌هایی ثبت کرده

03:54.420 --> 03:59.730
و بعد جزئیات همه محصولاتی که به اون سفارش‌ها مربوط هستن رو هم از سرویس B بگیریم.

03:59.730 --> 04:01.860
و جزئیات اون محصولات رو هم از سرویس B دریافت می‌کنیم.

04:02.590 --> 04:07.480
این یکی از روش‌های ممکن برای انجام ارتباط آسنکرون با استفاده از eventهاست.

04:07.500 --> 04:12.540
حالا می‌خوام دوباره تاکید کنم که این روش خیلی در دنیای واقعی استفاده نمی‌شه و دلیل خوبی هم داره.

04:12.540 --> 04:15.390
دلیلش اینه که تقریباً تمام معایب ارتباط سینکرون رو داره،

04:15.510 --> 04:21.900
و علاوه‌ بر اون، معایب اضافه‌تری هم داره که باید در نظر بگیریم.

04:24.060 --> 04:27.930
اول از همه باید بگم که این مدل از نظر مفهومی خیلی راحت نیست.

04:29.120 --> 04:30.550
سرویس به دیتابیس نیاز نداره؟

04:30.560 --> 04:31.640
بله، هنوز درسته.

04:32.030 --> 04:36.950
اما با این سبک ارتباط آسنکرون، همچنان بین سرویس‌ها وابستگی وجود داره.

04:37.310 --> 04:42.080
اگر هر کدوم از این eventها پردازش نشن، کل درخواست با خطا مواجه می‌شه یا تایم‌اوت می‌کنه.

04:43.130 --> 04:49.130
ما هنوز فقط به اندازه کندترین event می‌تونیم پاسخ رو دریافت کنیم.

04:49.310 --> 04:53.900
و دوباره، ممکنه شبکه‌ای از eventهای مختلف بسازیم که پیچیده و غیرقابل کنترل بشه.

04:54.260 --> 04:59.480
پس این سبک ارتباط آسنکرون بهترین گزینه نیست، ولی همچنان باید بدونی که وجود داره.

05:02.010 --> 05:02.360
خب،

05:02.370 --> 05:05.250
فقط یک گزینه دیگه باقی مونده.

05:05.280 --> 05:10.170
یادت باشه لحظاتی پیش گفتم که دو روش برای ارتباط آسنکرون داریم تا این مشکل رو حل کنیم.

05:10.170 --> 05:12.290
پس اینجا یه توقف کوتاه داشته باشیم.

05:12.300 --> 05:13.650
تو ویدیو بعدی برمی‌گردیم

05:13.660 --> 05:18.300
و به روش دوم ارتباط آسنکرون که قراره ازش استفاده کنیم نگاه می‌ندازیم.
