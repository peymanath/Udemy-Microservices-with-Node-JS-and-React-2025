WEBVTT

00:00.960 --> 00:05.370
تو ویدیوی قبلی درباره Docker صحبت کردیم و گفتیم که Docker باعث میشه اجرای برنامه‌هامون خیلی راحت بشه.

00:05.370 --> 00:07.620
حالا می‌خوایم وارد بحث Kubernetes بشیم.

00:07.830 --> 00:11.470
تو صحبت‌هایی که قراره در مورد Kubernetes داشته باشیم، ممکنه در ابتدا متوجه نشی که ارتباط بین Docker و Kubernetes دقیقاً چیه.

00:11.490 --> 00:15.530
و شاید در پایان این ویدیو بگی: خب، حالا دوباره بگو چرا Docker مهمه؟

00:15.540 --> 00:17.310
چرا اصلاً رفتیم سراغش؟

00:17.310 --> 00:21.600
نگران نباش، همه چیز به مرور زمان برات روشن میشه.

00:21.600 --> 00:21.890
فعلاً...

00:21.900 --> 00:22.800
تمرکزمون رو بزاریم روی Kubernetes.

00:22.950 --> 00:23.730
بریم ببینیم چطوری یکی از مشکلات اساسی‌مون رو توی مقیاس‌پذیری حل می‌کنه.

00:23.730 --> 00:26.880
همون مشکلی که توی ویدیوهای قبلی باهاش روبه‌رو شدیم.

00:26.880 --> 00:31.560
خب اول از همه: Kubernetes چیه؟

00:31.560 --> 00:34.470
Kubernetes یک ابزار برای اجرای چندین کانتینر به صورت هم‌زمانه.

00:35.100 --> 00:35.320
یعنی چی؟

00:35.430 --> 00:37.440
یعنی وقتی از Kubernetes استفاده می‌کنیم،

00:37.530 --> 00:41.820
بهش یه سری فایل پیکربندی می‌دیم که داخلش مشخص می‌کنیم چه کانتینرهایی قراره اجرا بشن.

00:42.520 --> 00:46.600
Kubernetes بر اساس این فایل‌ها، کانتینرها رو می‌سازه و برنامه‌هامون رو داخل اون‌ها اجرا می‌کنه.

00:46.630 --> 00:51.070
همچنین ارتباط شبکه‌ای بین این کانتینرها رو هم خودش هندل می‌کنه.

00:51.070 --> 00:52.570
یعنی ما لازم نیست نگران ارتباط بین سرویس‌ها باشیم.

00:52.990 --> 00:57.250
Kubernetes هم اجرای برنامه‌ها رو برامون مدیریت می‌کنه، هم ارتباط بین اون‌ها رو ساده می‌کنه.

00:57.250 --> 01:02.500
در واقع می‌تونیم بگیم Kubernetes یه ابزار برای اجرای چند برنامه مختلفه که ارتباط بینشون رو هم مدیریت می‌کنه.

01:02.500 --> 01:03.250
اما فقط تعریف گفتاری کافی نیست.

01:03.490 --> 01:08.950
بیایم یه نمودار ببینیم تا بهتر متوجه بشیم Kubernetes دقیقاً چیکار می‌کنه.

01:08.950 --> 01:11.710
توی Kubernetes ما چیزی به اسم Cluster داریم.

01:12.430 --> 01:16.390
یک Cluster مجموعه‌ای از ماشین‌های مجازیه.

01:16.390 --> 01:16.870
ممکنه فقط یک ماشین داشته باشه (مثل همین مثالی که الان می‌بینی)

01:16.870 --> 01:20.680
یا اینکه شامل صدها یا هزاران ماشین مختلف باشه.

01:22.120 --> 01:25.090
به هر کدوم از این ماشین‌های مجازی می‌گیم Node.

01:25.390 --> 01:28.540
همه این Nodeها تحت کنترل چیزی به اسم Master هستن.

01:28.570 --> 01:32.850
Master یه برنامه‌ست که مسئول مدیریت کل سیستم و همه‌ی nodeهاست.

01:32.860 --> 01:36.220
یعنی هم برنامه‌های در حال اجرا رو کنترل می‌کنه، هم وضعیت nodeها رو بررسی می‌کنه و کلی کار دیگه.

01:36.820 --> 01:42.490
ما به Kubernetes می‌گیم که چه برنامه‌هایی رو اجرا کنه، اون هم خودش تصمیم می‌گیره کدوم node این کار رو انجام بده.

01:42.490 --> 01:43.330
تقریباً به صورت تصادفی.

01:43.330 --> 01:48.730
یعنی تو فقط بهش می‌گی چه چیزی رو اجرا کن، خودش تشخیص می‌ده کجا و چطوری اجرا بشه.

01:48.730 --> 01:53.320
و در ادامه می‌بینی که چقدر این کارها رو برات راحت می‌کنه.

02:04.630 --> 02:07.720
یادت باشه، node همون ماشین مجازیه که برنامه‌هامون روش اجرا میشه.

02:08.290 --> 02:10.720
حالا بریم ببینیم این ساختار در عمل چطور پیاده‌سازی میشه.

02:12.230 --> 02:17.390
ما فایل‌هایی به اسم فایل پیکربندی می‌نویسیم که به Kubernetes دقیقاً می‌گن چه کاری انجام بده.

02:17.390 --> 02:19.700
مثلاً می‌گیم: دو نسخه از سرویس post اجرا کن.

02:19.880 --> 02:26.780
و مطمئن شو که بعد از ایجاد این سرویس‌ها، بتونیم به‌سادگی بهشون دسترسی داشته باشیم.

02:26.780 --> 02:31.880
ما این فایل پیکربندی رو می‌نویسیم و می‌دیم به چیزی به اسم master توی Kubernetes.

02:32.390 --> 02:37.520
master اون فایل رو می‌خونه و سعی می‌کنه دقیقا همون دستوراتی که توش هست رو اجرا کنه.

02:38.120 --> 02:42.830
یعنی توی این مثال، دوتا نسخه از سرویس post رو می‌سازه و اونا رو داخل کانتینر اجرا می‌کنه.

02:44.120 --> 02:51.020
این نسخه‌ها به صورت تصادفی (تقریباً) روی nodeهای مختلف توی cluster اجرا می‌شن.

02:51.020 --> 02:52.580
که البته الگوریتم‌هایی برای انتخاب هست، ولی فعلاً فرض کنیم تصادفیه.

02:53.810 --> 02:57.050
حالا اینجا یه مشکلی مشابه مشکل‌های قبل داریم.

02:57.050 --> 03:01.400
چطوری event bus بفهمه که این نسخه‌های مختلف از سرویس post کجا اجرا شدن؟

03:01.400 --> 03:04.820
همون مشکلی که قبلاً باهاش روبه‌رو شدیم دوباره اینجا مطرح میشه.

03:05.460 --> 03:09.540
راه‌حل Kubernetes چیه؟

03:09.540 --> 03:15.030
Kubernetes به ما این امکان رو میده که یک سیستم واسط ایجاد کنیم که بتونیم درخواست‌ها رو بهش بفرستیم،

03:15.030 --> 03:17.010
و اون خودش تصمیم بگیره این درخواست به کدوم نسخه از سرویس بره.

03:17.550 --> 03:22.920
یعنی یه مسیریاب مرکزی می‌سازیم که درخواست رو به نسخه مناسب هدایت می‌کنه.

03:22.920 --> 03:27.720
به‌جای اینکه event bus مستقیماً با هر سرویس ارتباط بگیره، فقط با این مسیریاب در تماس میشه.

03:27.720 --> 03:28.770
این خیلی بهتره.

03:29.510 --> 03:34.070
پس فرض کن داخل cluster یه چیز مرکزی داریم که درخواست‌ها رو از همه می‌گیره و خودش توزیع می‌کنه.

03:34.070 --> 03:39.740
event bus فقط با اون ارتباط می‌گیره، و اون بقیه کارها رو انجام می‌ده.

03:39.740 --> 03:42.230
مثل یه درگاه واحد برای ارتباط بین سرویس‌ها.

03:42.650 --> 03:47.600
مثلاً فرض کنیم یه نسخه از سرویس post روی node شماره ۱ اجرا شده، یکی دیگه روی node شماره ۲.

03:47.600 --> 03:49.640
و event bus روی node شماره ۳ قرار داره.

03:49.640 --> 03:52.130
اگه Kubernetes نداشتیم،

03:52.610 --> 03:58.280
باید به event bus یاد می‌دادیم چطوری مستقیماً به node ۲ و سرویس post داخلش دسترسی پیدا کنه.

03:58.280 --> 04:03.170
و همین‌طور باید مسیر دستی برای ارتباط با node ۱ و سرویسش مشخص می‌کردیم.

04:03.380 --> 04:08.990
که قبلاً هم گفتیم این روش خیلی سخت، شکننده و اشتباه‌پذیره.

04:08.990 --> 04:11.030
و اصلاً نمی‌خوایم این‌طوری پیش بریم.

04:11.030 --> 04:14.900
در عوض، فقط کافیه به event bus یاد بدیم با اون کانال ارتباطی مرکزی صحبت کنه.

04:15.140 --> 04:21.440
اگه درخواست رو به اون کانال بفرسته، خود سیستم تشخیص می‌ده که باید به کدوم نسخه از سرویس post ارسال بشه.

04:22.200 --> 04:27.000
و ما مطمئن می‌شیم که اون درخواست به درستی به همه نسخه‌های سرویس post منتقل میشه.

04:32.420 --> 04:36.980
در نتیجه، دیگه لازم نیست نگران جزئیات پیچیده اتصال بین سرویس‌ها باشیم.

04:36.980 --> 04:41.900
فقط کافی‌یه بگیم: یه درخواست بفرست به این سرویس، و Kubernetes خودش بقیه کارها رو هندل می‌کنه.

04:43.220 --> 04:48.020
دلیل اصلی‌ای که ما توی معماری مایکروسرویس‌ها از Kubernetes استفاده می‌کنیم اینه که ارتباط بین سرویس‌ها رو خیلی ساده و روان می‌کنه.

04:48.020 --> 04:51.080
همچنین راه‌اندازی نسخه‌های جدید از سرویس‌ها یا مقیاس‌دهی بهشون رو خیلی راحت می‌کنه.

04:51.110 --> 04:56.420
یعنی اگر بخوایم مثلاً تعداد نسخه‌های در حال اجرای یه سرویس رو افزایش بدیم، این کار به سادگی انجام میشه.

04:56.420 --> 04:59.060
همه چیز به صورت ساده و قابل مدیریت میشه.

05:00.010 --> 05:03.880
شاید الان بگی: صبر کن ببینم، ما که نمی‌خواستیم سرویس‌هامون مستقیم با هم ارتباط بگیرن!

05:03.880 --> 05:07.810
مگه هدف مایکروسرویس این نیست که سرویس‌ها مستقل باشن؟

05:07.810 --> 05:08.260
درسته.

05:08.410 --> 05:09.280
ولی دقت کن...

05:09.280 --> 05:14.080
ما نمی‌خوایم ارتباط‌ها «همزمان» باشن (synchronous)، ولی همچنان لازم داریم که سرویس‌ها با هم تبادل اطلاعات داشته باشن.

05:14.080 --> 05:18.980
در واقع، برنامه‌ها هنوز هم باید با هم در تماس باشن — مثلاً با Event Bus یا دیتابیس خودشون.

05:19.000 --> 05:24.370
یعنی مثلاً سرویس‌ها باید بتونن با یک event bus مشترک صحبت کنن یا به دیتابیس خودشون وصل بشن.

05:24.370 --> 05:28.660
داشتن یه کانال ارتباطی مرکزی این ارتباطات رو ساده‌تر و قابل اعتمادتر می‌کنه.

05:28.660 --> 05:29.200
خیلی مهمه.

05:29.350 --> 05:35.050
Kubernetes این زیرساخت ارتباطی رو ایجاد می‌کنه تا سرویس‌ها بتونن بدون درگیری با جزئیات، با هم کار کنن.

05:36.070 --> 05:36.390
خب،

05:36.400 --> 05:41.470
این یه معرفی خیلی مختصر بود از Kubernetes و اینکه چرا توی معماری مایکروسرویس انقدر مهمه.

05:41.770 --> 05:45.430
حالا اینجا یه توقف کوتاه می‌کنیم و بعد می‌ریم سراغ بررسی دقیق‌تر Docker.

05:45.430 --> 05:47.050
تا بیشتر باهاش آشنا بشیم.
