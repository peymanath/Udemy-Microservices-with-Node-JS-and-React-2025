WEBVTT

00:00.960 --> 00:05.370
In the last video, we introduced this idea of Docker and we said that Docker makes it really easy to

00:05.370 --> 00:07.620
start up and run our different programs.

00:07.830 --> 00:11.470
We're now going to start to talk about Kubernetes now as we talk about Kubernetes.

00:11.490 --> 00:15.530
We're not going to immediately see why Docker and Kubernetes are so nice together.

00:15.540 --> 00:17.310
It's not going to be immediately evident.

00:17.310 --> 00:21.600
And you might be sitting there saying at the very end of this video, Wait, why do we care about Docker

00:21.600 --> 00:21.890
again?

00:21.900 --> 00:22.800
Tell me about that.

00:22.950 --> 00:23.730
Well, don't worry.

00:23.730 --> 00:26.880
All this stuff is going to become more evident in due time for right now.

00:26.880 --> 00:31.560
Let's just focus a little bit on Kubernetes and see how it solves one of those issues that we ran into

00:31.560 --> 00:34.470
a little bit earlier when we were talking about scaling our application.

00:35.100 --> 00:35.320
Okay.

00:35.430 --> 00:37.440
So first off, what is Kubernetes?

00:37.530 --> 00:41.820
Kubernetes is a tool for running a bunch of different containers together.

00:42.520 --> 00:46.600
When we make use of Kubernetes, we're going to give it some configuration files.

00:46.630 --> 00:51.070
These configuration files are going to tell Kubernetes about the different containers that we want to

00:51.070 --> 00:52.570
run in our application.

00:52.990 --> 00:57.250
Kubernetes is then going to create these containers that are going to run our programs for us, and

00:57.250 --> 01:02.500
it's going to handle communication or essentially network requests between all these different containers

01:02.500 --> 01:03.250
as well.

01:03.490 --> 01:08.950
So we can really imagine Kubernetes as a tool to run some different programs and make communication

01:08.950 --> 01:11.710
between those programs very easy and straightforward.

01:12.430 --> 01:16.390
Of course, just giving you a verbal definition of this or a verbal, verbal description is not super

01:16.390 --> 01:16.870
helpful.

01:16.870 --> 01:20.680
So let's take a look at a diagram and better understand what Kubernetes is all about.

01:22.120 --> 01:25.090
So Kubernetes, we create something called a cluster.

01:25.390 --> 01:28.540
A cluster is a set of different virtual machines.

01:28.570 --> 01:32.850
It can have as few as one virtual machine, like what you see right here.

01:32.860 --> 01:36.220
Or it can have many hundreds or thousands of virtual machines.

01:36.820 --> 01:42.490
All these different virtual machines we refer to as nodes, they are all managed by something called

01:42.490 --> 01:43.330
a master.

01:43.330 --> 01:48.730
Master is essentially a program that's going to manage everything inside of our cluster, all the different

01:48.730 --> 01:53.320
programs that are running, all the different aspects of these virtual machines and many other things.

01:54.100 --> 01:57.400
We are going to tell Kubernetes to run some programs for us.

01:57.400 --> 02:03.280
When we do so, it's going to take our program and then more or less randomly assign it to be executed

02:03.280 --> 02:04.630
by one of these nodes.

02:04.630 --> 02:07.720
And again, remember, a node is really just a virtual machine.

02:08.290 --> 02:10.720
So let's take a look at what this would really look like in practice.

02:12.230 --> 02:17.390
So we are going to create some configuration files that are going to provide some very explicit directions

02:17.390 --> 02:19.700
to Kubernetes on what we want it to do.

02:19.880 --> 02:26.780
So we might write a configuration file that says, run two copies of our post service and also make

02:26.780 --> 02:31.880
sure that we can very easily access these post services after they've been created.

02:32.390 --> 02:37.520
So you and I are going to write that configuration file and then feed it into this master thing.

02:38.120 --> 02:42.830
Master is going to read that configuration file and then try to implement all the steps we've written

02:42.830 --> 02:43.760
out inside there.

02:44.120 --> 02:51.020
So in this case, it's going to attempt to create two different copies of our post service wrapped up

02:51.020 --> 02:52.580
inside of containers.

02:53.810 --> 02:57.050
These will be randomly assigned again, more or less randomly.

02:57.050 --> 03:01.400
There actually is some science to it, but we can imagine right now they will be assigned to be executed

03:01.400 --> 03:04.820
by some different virtual machines or nodes inside of our cluster.

03:05.460 --> 03:09.540
Now in this scenario, we're kind of back in the same problem we had before where it could potentially

03:09.540 --> 03:15.030
be really hard for something like our event bus to figure out in how to reach out to say this copy of

03:15.030 --> 03:17.010
the post service and that post service.

03:17.550 --> 03:22.920
So the big thing that Kubernetes does for us is give us the ability to just kind of arbitrarily send

03:22.920 --> 03:27.720
requests or communicate between these different services with some kind of third party thing that we

03:27.720 --> 03:28.770
are going to create.

03:29.510 --> 03:34.070
So in short, you can kind of imagine down here that we're going to create something inside of our cluster

03:34.070 --> 03:39.740
that we can just send requests to, and it will automatically figure out how to route requests off to

03:39.740 --> 03:42.230
the appropriate service that is running inside of our application.

03:42.650 --> 03:47.600
So for example, let's imagine that we've got a copy of the post service on node one or virtual machine

03:47.600 --> 03:49.640
number one, one on number two.

03:49.640 --> 03:52.130
And then our event bus is over here on number three.

03:52.610 --> 03:58.280
If we were not using Kubernetes, we would have to somehow teach the event bus how to directly reach

03:58.280 --> 04:03.170
out over to this second virtual machine and more specifically, the post service running on it.

04:03.380 --> 04:08.990
And we'd have to figure out how to do the same thing to have it reach out to this first virtual machine

04:08.990 --> 04:11.030
and the service running on there as well.

04:11.030 --> 04:14.900
And again, as we discussed in the last couple of videos, that is not what we want to do.

04:15.140 --> 04:21.440
So instead, we will simply teach our event bus how to reach out to this very common communication channel.

04:22.200 --> 04:27.000
If we send a request off to this very common communication channel, we can then be guaranteed that

04:27.000 --> 04:31.500
it will be sent off or forwarded on to every copy of our post service.

04:32.420 --> 04:36.980
And so we don't have to worry about all these intricate connection details or stuff like that.

04:36.980 --> 04:41.900
We can simply say, make request to this service and Kubernetes is going to take care of everything

04:41.900 --> 04:42.590
from there.

04:43.220 --> 04:48.020
So the big reason that you and I are using Kubernetes around microservices is that it's going to make

04:48.020 --> 04:51.080
communication very easy and straightforward.

04:51.110 --> 04:56.420
It's also going to make creating services like launching new copies and scaling the number of copies.

04:56.420 --> 04:59.060
We're running very easy and straightforward as well.

05:00.010 --> 05:03.880
Now, this whole idea of having our services communicate with each other, you might be sitting there

05:03.880 --> 05:07.810
and saying, Wait, Stephen, I thought we didn't want our services to communicate directly with each

05:07.810 --> 05:08.260
other.

05:08.410 --> 05:09.280
Well, yes.

05:09.280 --> 05:14.080
Remember, we are not using synchronous communication between our services, but there still are programs

05:14.080 --> 05:18.980
that ultimately do have to talk with each other inside of our microservices applications.

05:19.000 --> 05:24.370
We still need to have our services communicate with some common event bus and we need to make sure at

05:24.370 --> 05:28.660
some point in time that our services can also communicate with, say, a database that is being assigned

05:28.660 --> 05:29.200
to it.

05:29.350 --> 05:35.050
And having this common communication channel is going to make that process a lot easier and more straightforward.

05:36.070 --> 05:36.390
Okay.

05:36.400 --> 05:41.470
So that's just a very brief introduction to Kubernetes and why we care about it in the world of microservices.

05:41.770 --> 05:45.430
So we're going to take a pause right here and then start to discuss Docker a little bit more and get

05:45.430 --> 05:47.050
more familiar with it in just a moment.
