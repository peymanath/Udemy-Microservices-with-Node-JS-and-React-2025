WEBVTT

00:01.190 --> 00:03.700
اپلیکیشن ما الان تقریباً به حالت کامل رسیده.

00:03.710 --> 00:07.730
حالا می‌خوایم به این فکر کنیم که چطور می‌تونیم این اپلیکیشن رو آنلاین منتشر (deploy) کنیم.

00:07.760 --> 00:12.320
بیایم اول یه مرور سریع داشته باشیم که الان روی سیستم خودمون، این اپلیکیشن چطور اجرا میشه.

00:12.320 --> 00:13.130
روی کامپیوترت:

00:13.490 --> 00:16.250
ما سرویس‌های posts، comments، query، moderation و event-bus رو داریم.

00:16.370 --> 00:19.190
همه‌شون روی پورت‌های مشخصی در حال اجرا هستن و می‌تونن مستقیماً با هم ارتباط برقرار کنن.

00:19.190 --> 00:24.020
یعنی سرویس‌ها می‌تونن مستقیم درخواست بفرستن یا پیام ارسال کنن.

00:24.020 --> 00:27.950
ارتباط ساده و مستقیمی بین همه‌ی سرویس‌ها وجود داره.

00:27.980 --> 00:31.520
حالا سوال اینجاست که چطور می‌تونیم همین ساختار رو با کمترین تغییر ممکن، به محیط آنلاین منتقل کنیم؟

00:31.850 --> 00:37.430
یه راه خیلی ساده اینه که بریم سراغ سرویس‌هایی مثل DigitalOcean، AWS، Azure یا هر جای دیگه، و یه ماشین مجازی اجاره کنیم.

00:37.430 --> 00:38.330
یعنی یه سرور اختصاصی کوچیک.

00:38.870 --> 00:45.230
بعد کدهای سورس‌مون رو روی اون سرور کپی کنیم و دقیقاً به همون شکلی که الان این سرویس‌ها رو اجرا کردیم، اونجا هم اجراشون کنیم.

00:45.230 --> 00:47.300
یعنی هر سرویس رو با همون پورت روی همون ماشین اجرا کنیم.

00:47.750 --> 00:51.520
در این حالت، سرویس‌ها همچنان می‌تونن با localhost و پورت‌های 4000، 4001 و ... با هم صحبت کنن.

00:51.530 --> 00:56.660
این روش قطعاً جواب می‌ده و مشکلی نداره.

00:56.660 --> 00:58.790
اما...

00:59.180 --> 01:03.890
اگه یه مقدار عمیق‌تر بهش فکر کنیم و بخوایم در آینده اپلیکیشن رو گسترش بدیم، کار کمی پیچیده‌تر میشه.

01:03.890 --> 01:07.100
بذار دقیق‌تر توضیح بدم که چرا.

01:08.150 --> 01:10.270
فرض کن سرویس comments خیلی شلوغ شده.

01:10.280 --> 01:14.330
مثلاً تعداد زیادی کاربر دارن هم‌زمان کامنت ایجاد می‌کنن.

01:14.330 --> 01:17.540
خب طبیعیه که اون یکی سرویس‌مون کم بیاره.

01:17.960 --> 01:19.040
در این حالت،

01:19.550 --> 01:25.700
شاید بخوایم برای مدیریت این حجم از درخواست، دو یا سه نسخه‌ی دیگر از سرویس comments ایجاد کنیم.

01:25.850 --> 01:31.130
یعنی سه نسخه‌ی هم‌زمان از این سرویس داشته باشیم تا بار بین‌شون تقسیم بشه.

01:31.460 --> 01:36.260
یه راه ساده اینه که روی همون ماشین مجازی، دو نسخه‌ی دیگه از comment service اجرا کنیم.

01:36.260 --> 01:39.050
الان می‌تونیم این سه سرویس رو با هم load balance کنیم.

01:39.710 --> 01:45.020
یعنی وقتی درخواست جدیدی برای ثبت کامنت میاد، به‌صورت تصادفی بین این سه سرویس تقسیم بشه.

01:45.020 --> 01:46.370
و فشار بینشون پخش بشه.

01:46.460 --> 01:49.850
اما این روش مشکلاتی هم داره.

01:51.280 --> 01:55.540
مثلاً نسخه‌های اضافی از comment service باید روی پورت‌های متفاوتی اجرا بشن.

01:55.540 --> 02:01.750
یعنی باید برای هرکدوم یک پورت جدید رزرو کنیم تا روی هم تداخل نداشته باشن.

02:11.480 --> 02:15.530
مثلاً شاید بخوایم این دو نسخه جدید از سرویس کامنت رو روی پورت‌های 4006 و 4007 اجرا کنیم.

02:15.890 --> 02:21.590
این موضوع مهمه، چون یادت باشه که event bus باید دقیقاً بدونه هر سرویس روی چه IP و پورتی در دسترسه تا بتونه eventها رو براش بفرسته.

02:21.590 --> 02:23.990
یعنی چی؟

02:24.380 --> 02:29.480
یعنی به محض اینکه این نسخه‌های جدید از سرویس comments رو ایجاد کنیم، باید بریم سراغ کد event bus.

02:29.480 --> 02:31.730
در واقع، الان این کار رو انجام می‌دم.

02:31.730 --> 02:33.670
فایل index مربوط به event bus رو باز می‌کنم.

02:33.680 --> 02:36.230
و اونجایی که داریم event رو به سرویس‌ها ارسال می‌کنیم پیدا می‌کنم.

02:36.890 --> 02:41.420
اونجا مجبوریم دو خط جدید اضافه کنیم برای پورت‌های 4006 و 4007.

02:41.420 --> 02:48.830
یعنی مثلاً دو تا درخواست HTTP دیگه مثل اونایی که برای 4000 و 4001 داریم، برای اینا هم اضافه کنیم.

02:50.480 --> 02:55.370
حالا اگر از این روش استفاده کنیم، داریم بین تعداد سرویس‌هایی که اجرا شدن و کد واقعی‌مون وابستگی مستقیم ایجاد می‌کنیم.

02:55.370 --> 02:59.090
اگه یه روز بخوایم تعداد سرویس‌های comment رو کم یا زیاد کنیم، باید کد event bus رو هم تغییر بدیم و دوباره منتشرش کنیم.

02:59.270 --> 03:04.160
و همون‌طور که می‌تونی حدس بزنی، این اصلاً خوب نیست و کلی دردسر داره.

03:04.160 --> 03:08.900
سناریو بدتر میشه اگه ببینیم این چند نسخه از سرویس comment روی همون ماشین مجازی خیلی فشار میارن و سرور کم میاره.

03:09.050 --> 03:12.410
تو این حالت، ممکنه تصمیم بگیریم یه ماشین مجازی دوم بگیریم و اون دو نسخه جدید رو روی اون اجرا کنیم.

03:13.590 --> 03:18.600
مثلاً همچنان از پورت‌های 4006 و 4007 استفاده کنیم، ولی حالا روی یه سرور دیگه.

03:18.600 --> 03:21.900
در این صورت، event bus باید بدونه که این پورت‌ها روی یه IP دیگه‌ان.

03:22.200 --> 03:27.720
یعنی علاوه بر نگه‌داشتن لیست پورت‌ها، باید بتونه تشخیص بده هر پورت روی کدوم ماشین مجازیه.

03:28.020 --> 03:29.790
و به اون IP خاص درخواست ارسال کنه.

03:31.720 --> 03:38.230
یعنی دیگه فقط نوشتن پورت کافی نیست، باید IP ماشین دوم هم در کد لحاظ بشه.

03:38.230 --> 03:43.720
و این باعث میشه event bus عملاً به ساختار شبکه ما وابسته بشه، که خیلی بده.

03:43.720 --> 03:49.870
حالا نه‌تنها باید پورت‌ها رو توی کد بنویسیم، بلکه باید IP سرورهای دیگه هم دستی توی کد وارد کنیم.

03:49.870 --> 03:53.170
و همه اینا یعنی وابستگی سفت و سخت، کد سخت‌قابل‌تغییر و پر از خطا.

03:53.750 --> 03:56.630
یعنی دوباره باید بریم داخل فایل event bus

03:56.630 --> 04:01.850
و به‌جای اینکه به localhost درخواست بفرستیم، باید آدرس IP ماشین مجازی دوم رو بنویسیم.

04:01.850 --> 04:02.840
یه چیزی شبیه این:

04:03.730 --> 04:04.420
http://192.168.x.x:4006

04:05.100 --> 04:08.700
و همون‌طور که می‌تونی تصور کنی، این کار واقعاً خسته‌کننده، تکراری و اشتباه‌پذیره.

04:09.940 --> 04:11.670
بیایم یه سناریوی دیگه هم تصور کنیم.

04:11.680 --> 04:14.060
فقط یکی دیگه، خیلی سریع.

04:14.080 --> 04:19.050
فرض کنیم سایت ما فقط در بعضی ساعات روز خیلی پربازدید میشه.

04:19.060 --> 04:25.330
مثلاً ساعت ۱۰ صبح کاربران زیادی وارد سایت می‌شن و شروع می‌کنن به گذاشتن کامنت.

04:25.330 --> 04:29.830
تو این ساعت، لازمه چند نسخه‌ی اضافی از سرویس کامنت‌مون فعال باشه تا فشار رو کنترل کنه.

04:29.830 --> 04:35.980
اما مثلاً ساعت ۱ نصف شب که دیگه تقریباً هیچ‌کس وارد سایت نمی‌شه، شاید بهتر باشه برای کاهش هزینه، ماشین دوم رو خاموش کنیم.

04:35.980 --> 04:37.030
چون استفاده‌ای ازش نمی‌شه.

04:37.030 --> 04:43.510
در نتیجه، تصمیم می‌گیریم که اون سرویس‌های اضافی موقتاً خاموش بشن تا هزینه‌ی سرور کاهش پیدا کنه.

04:43.510 --> 04:47.230
یعنی موقتاً ماشین دوم رو خاموش می‌کنیم چون نیاز به اون سرویس‌های اضافه نداریم.

04:47.230 --> 04:49.570
همه چیز خوب به نظر می‌رسه، اما...

04:49.570 --> 04:52.540
حالا Event Bus ما باید بدونه که اون ماشین دوم خاموش شده و نباید سعی کنه بهش رویداد بفرسته.

04:53.200 --> 04:57.550
برای مدیریت این وضعیت، باید دوباره بریم سراغ کد Event Bus و یه شرط زمان اضافه کنیم.

04:57.550 --> 05:01.480
مثلاً بگیم اگه الان ساعت ۱ نصف شبه، این سرویس‌ها رو رد کن.

05:02.470 --> 05:06.880
یعنی شاید مجبور باشیم بنویسیم: اگر الان ساعت غیر از ۱ بامداده، رویدادها رو بفرست.

05:06.880 --> 05:10.090
در غیر این صورت، بی‌خیال اون دو سرویس بشو.

05:11.070 --> 05:14.370
اما همون‌طور که حدس می‌زنی، این کار خیلی غیرمنطقی و اشتباهه.

05:15.800 --> 05:17.690
ما نباید به زمان وابسته باشیم.

05:18.650 --> 05:21.890
نباید ساعت تعیین‌کننده‌ی این باشه که آیا رویداد رو به سرویس بفرستیم یا نه.

05:23.250 --> 05:28.110
این روش یعنی هر بار ساعت عوض شد یا وضعیت سرورها تغییر کرد، باید بریم کد Event Bus رو تغییر بدیم.

05:28.110 --> 05:28.980
کاملاً اشتباهه.

05:28.980 --> 05:33.090
هیچ‌وقت نباید بنویسیم که "اگر ساعت فلان بود، رویداد رو بفرست به فلان سرویس".

05:33.090 --> 05:34.740
این مسیریه که نباید واردش بشیم.

05:35.040 --> 05:39.570
الان داریم Event Bus رو به شیوه‌ای خیلی سخت‌گیرانه و صریح طراحی می‌کنیم که همه چیز رو باید خودش مدیریت کنه.

05:39.750 --> 05:45.000
یعنی Event Bus باید بدونه کدوم سرویس‌ها اجرا شدن، کدوم خاموشن، کی روشن می‌شن و همیشه رویداد رو به همه بفرسته.

05:45.000 --> 05:47.520
و همزمان باید وضعیت لحظه‌ای سرویس‌ها رو هم چک کنه.

05:47.520 --> 05:49.050
همه اینا خیلی پیچیده‌ست.

05:49.050 --> 05:54.330
به‌قدری پیچیده و سخت میشه که عملاً مدیریت همچین سیستمی از دست ما خارج میشه.

05:54.330 --> 05:57.060
و احتمال اینکه بتونیم درست پیادش کنیم خیلی کمه.

05:57.060 --> 05:59.730
بنابراین نتیجه واضحه.

06:00.030 --> 06:05.520
چیزی که الان روی سیستم لوکال ما خوب کار می‌کنه، توی دنیای واقعی و مقیاس بالا جواب نمی‌ده.

06:05.520 --> 06:07.140
ما یه راه حل بهتر می‌خوایم.

06:07.650 --> 06:12.150
نیاز داریم به یه سیستمی که خودش بفهمه چه سرویس‌هایی در حال اجرا هستن،

06:12.150 --> 06:14.820
بتونه خودکار سرویس جدید ایجاد کنه،

06:14.820 --> 06:21.090
و خودش تشخیص بده که آیا فلان سرویس فعاله یا نه و آیا اصلاً نیازه که بهش درخواست ارسال کنیم یا نه.

06:21.090 --> 06:26.850
این بحث ما رو می‌بره به سمت دو فناوری متن‌باز و بسیار مهم: Docker و Kubernetes.

06:26.850 --> 06:31.650
قراره وارد بحث مفصل این دوتا ابزار بشیم که توی ویدیوهای بعدی کامل بررسی‌شون می‌کنیم.

06:31.650 --> 06:35.400
پس اینجا یه توقف می‌کنیم و از ویدیوی بعدی با Docker شروع می‌کنیم.

06:36.000 --> 06:40.560
می‌خوایم اول با Docker بیشتر آشنا بشیم و بعدش بریم سراغ Kubernetes.
