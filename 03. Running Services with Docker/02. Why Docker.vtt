WEBVTT

00:01.250 --> 00:04.850
توی ویدیوی قبلی درباره چندتا مشکلی صحبت کردیم که احتمالاً وقتی بخوایم اپلیکیشن رو دیپلوی کنیم، باهاشون مواجه می‌شیم.

00:04.850 --> 00:06.420
توی این ویدیو قراره درباره Docker صحبت کنیم.

00:06.440 --> 00:09.400
می‌خوایم ببینیم چطور Docker می‌تونه کار ما رو خیلی راحت‌تر کنه، مخصوصاً وقتی بخوایم بریم سمت محیط production.

00:09.410 --> 00:13.520
خب، اصلاً Docker چیه؟

00:13.520 --> 00:15.650
با Docker ما یه‌سری چیز به اسم Container درست می‌کنیم.

00:15.920 --> 00:17.450
Container یعنی یه محیط اجرایی ایزوله‌شده.

00:17.780 --> 00:21.620
هر کانتینر شامل تمام چیزهاییه که برای اجرای یه برنامه خاص نیاز داریم.

00:21.710 --> 00:24.830
ما برای هر سرویس‌مون یه کانتینر جداگانه می‌سازیم.

00:24.830 --> 00:28.880
مثلاً یه کانتینر برای Event Bus، یکی برای Posts، یکی برای Comments و همین‌طور الی آخر.

00:29.240 --> 00:34.610
اگه نیاز داشته باشیم یه سرویس رو چندبار اجرا کنیم — مثلاً چند نسخه از سرویس کامنت — فقط کافیه یه کانتینر دیگه برای اون سرویس بسازیم.

00:34.760 --> 00:39.680
یعنی می‌تونیم تصور کنیم که هر کانتینر معادل یک نمونه اجرایی از یه سرویسه.

00:40.070 --> 00:45.650
حالا بیایم ببینیم اصلاً چرا باید از Docker استفاده کنیم؟ چه مشکلی رو حل می‌کنه؟

00:45.650 --> 00:48.050
در حال حاضر، اجرای اپلیکیشن ما یه‌سری فرض مهم در مورد محیط اجرا داره.

00:48.770 --> 00:54.020
مثلاً اینکه ما داریم فرض می‌کنیم NPM و Node روی سیستم‌مون نصب هستن.

00:54.050 --> 00:55.700
این خودش یه وابستگی پنهان بزرگه.

00:56.600 --> 01:00.890
یه چیز دیگه هم هست: حتی نحوه اجرای برنامه‌مون هم دقیقاً باید مشخص باشه.

01:01.370 --> 01:07.160
یعنی باید بدونیم که دقیقاً چه دستوری اجرا می‌کنه — مثلاً همین `npm start`.

01:07.160 --> 01:08.420
وگرنه چیزی بالا نمیاد.

01:08.780 --> 01:10.190
پس چی شد؟

01:10.490 --> 01:12.280
برای اجرای برنامه‌مون، چندتا فرض بزرگ داریم:

01:12.290 --> 01:14.400
یکی اینکه NPM و Node نصب هستن،

01:14.420 --> 01:21.170
و دوم اینکه دقیقاً باید بدونیم چطوری برنامه رو اجرا کنیم، با چه دستوری و با چه پیکربندی.

01:21.380 --> 01:25.790
همه اینا باعث می‌شن راه‌اندازی پروژه هم سخت‌تر بشه، هم خطاپذیرتر.

01:26.180 --> 01:29.540
هدف اصلی Docker اینه که این مشکلات رو حل کنه.

01:29.540 --> 01:33.320
هم راه‌اندازی رو آسون‌تر می‌کنه، هم وابستگی به محیط توسعه رو حذف می‌کنه.

01:35.240 --> 01:40.640
یعنی دیگه مهم نیست روی چه سیستمی اجراش می‌کنی — همه چیز توی کانتینر بسته‌بندی شده.

01:40.640 --> 01:42.260
این یعنی تکرارپذیری و قابل اطمینان بودن.

02:07.780 --> 02:11.560
ما قراره همه‌ی وابستگی‌هایی که یه برنامه نیاز داره رو داخل یه محیط ایزوله‌شده بسته‌بندی کنیم.

02:11.560 --> 02:16.650
یعنی چی؟ یعنی مثلاً NPM و Node رو هم داخل همون محیط (کانتینر) قرار می‌دیم.

02:16.660 --> 02:20.800
و علاوه‌بر اون، داخل کانتینر اطلاعات مربوط به نحوه‌ی اجرای برنامه رو هم قرار می‌دیم.

02:20.800 --> 02:21.940
یعنی دقیقاً می‌گیم با چه دستوری اجرا بشه.

02:22.560 --> 02:27.030
پس الان فقط کافیه بدونی که Docker اجرای هر برنامه‌ای رو — نه فقط Node.js — خیلی راحت می‌کنه.

02:27.030 --> 02:33.870
فرقی نمی‌کنه با چه زبان یا پلتفرمی طرف باشی؛ Docker اجراش رو ساده و قابل پیش‌بینی می‌کنه.

02:33.870 --> 02:36.620
هر برنامه‌ای که فکرش رو بکنی، با Docker راحت اجرا می‌شه.

02:36.630 --> 02:39.930
و اینجاست که قدرت واقعی Docker خودشو نشون می‌ده.

02:40.320 --> 02:42.000
حالا چرا این موضوع مهمه؟

02:42.030 --> 02:43.570
بذار همین‌جا یه توقف کوتاه داشته باشیم.

02:43.590 --> 02:47.670
توی ویدیوی بعدی قراره وارد بحث Kubernetes بشیم.

02:47.670 --> 02:52.290
و می‌بینی که Docker و این ایده‌ی اجرای راحت برنامه چقدر با Kubernetes خوب ترکیب می‌شن.
