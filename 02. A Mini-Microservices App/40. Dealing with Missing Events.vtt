WEBVTT

00:01.030 --> 00:05.560
Our application is now working pretty well, but at the end of the last video we saw a little issue,

00:05.560 --> 00:09.220
and this issue might be something that's been kind of nagging in the back of your head throughout this

00:09.220 --> 00:10.230
entire course.

00:10.240 --> 00:14.350
What happens to our application when a service goes down for some period of time?

00:14.680 --> 00:15.850
We just saw that in the last video.

00:15.850 --> 00:21.280
With the moderation service going down, we created a comment while the moderation service was down

00:21.280 --> 00:25.330
and now this comment is going to be forever stuck in the pending state.

00:25.630 --> 00:26.950
So how do we deal with this?

00:27.100 --> 00:30.670
Let's take a look at a diagram to better understand what the real issue here is.

00:31.460 --> 00:31.790
Okay.

00:31.790 --> 00:34.300
So in this diagram, kind of hard to understand what's going on.

00:34.310 --> 00:36.700
This is kind of a time sequence diagram.

00:36.710 --> 00:41.780
So we start off time of our application, starting up for the very first time right up here, and we

00:41.780 --> 00:44.240
have time flowing down or vertically.

00:45.700 --> 00:49.000
In our application, we've got the event bus, the green lines throughout.

00:49.000 --> 00:53.380
All these different services indicate times in which the service was successfully running.

00:53.770 --> 00:56.350
So we're going to say that our event bus was running the whole time.

00:56.380 --> 00:58.180
Post was running comments and query.

00:58.180 --> 01:02.470
Those were all running for the entire time that our application has been up and running.

01:03.040 --> 01:06.190
And during that time, maybe we've had a couple of events flow out.

01:06.220 --> 01:12.100
So maybe event one went out to post comments, query and moderation successfully because all those services

01:12.100 --> 01:14.320
were up at the time that event was sent out.

01:14.920 --> 01:19.690
Well, let's imagine that for some period of time indicated by this red line right here, maybe the

01:19.690 --> 01:21.550
moderation service was down.

01:22.120 --> 01:27.880
So event two and three might have been emitted from the event bus gone over to our post, successfully

01:27.880 --> 01:33.670
went to comments and queries successfully, but then failed to be delivered over to the moderation service.

01:34.390 --> 01:39.250
And then maybe some time later Moderation Service came up and it received Event four.

01:39.490 --> 01:41.950
But Events two and three have now been lost to time.

01:41.950 --> 01:46.390
We don't currently have any way to tell moderation about these events in how they just occurred.

01:48.200 --> 01:51.620
Now this is the scenario in which a service goes down for some little period of time.

01:51.620 --> 01:56.330
But there's another scenario that you've probably been wondering about again throughout the first half

01:56.330 --> 01:57.370
of this course already.

01:57.380 --> 02:02.990
What happens if we're using this kind of event style approach and we don't bring up or we don't even

02:02.990 --> 02:07.040
create a service until maybe sometime in the future?

02:07.040 --> 02:11.750
So in this diagram, let's imagine that we did not initially create our query service.

02:11.900 --> 02:17.390
And so maybe we've been running post comments in moderation for days, maybe even years, and they have

02:17.390 --> 02:22.340
tons of data inside them and they've already received tons of events, but maybe we only created that

02:22.340 --> 02:24.770
query service like one year down the line.

02:24.920 --> 02:29.090
And so we're creating this query service, but it's already missed out on all these different events.

02:29.090 --> 02:31.490
How do we somehow get query into sync?

02:31.520 --> 02:36.950
How do we get all the existing posts and comments and results of moderation over to the query service?

02:37.750 --> 02:41.290
Well, as usual, there's a couple of different ways to handle all these different cases.

02:41.290 --> 02:43.510
So let's take a look at some possible solutions.

02:45.090 --> 02:46.410
So here's option number one.

02:46.680 --> 02:50.880
For option number one, we're going to imagine that we've had our post service in common, service running

02:50.880 --> 02:53.130
for the entire lifetime of our application.

02:53.430 --> 02:57.240
And then maybe one year into the future, we create the query service.

02:57.510 --> 03:02.610
The query service, of course, needs to know about all of the posts that exist and all of the comments.

03:02.610 --> 03:06.090
So we somehow need to get query into sync with everything else.

03:06.800 --> 03:10.880
One way or option number one would be to use synchronous requests.

03:11.450 --> 03:16.880
So the instant we launch query, maybe we would have some code inside of the query service to make a

03:16.880 --> 03:21.590
direct network requests over to post and say, give me a list of all of your posts.

03:21.860 --> 03:26.720
It could get all the different posts that exist inside the post service via plain network requests.

03:27.580 --> 03:31.960
Once it stored all those posts, it could then turn round to the Common Service and also make a sync

03:31.960 --> 03:35.260
request directly over and say, Give me all the comments you have.

03:35.650 --> 03:38.530
And then I could store all those comments with the associated posts.

03:39.390 --> 03:42.270
Now the downside to this approach is pretty clear.

03:42.270 --> 03:44.370
We are falling back to synchronous requests.

03:44.760 --> 03:50.130
The real downside here is that we would have to have some code inside of posts and comments just to

03:50.130 --> 03:53.640
service or kind of handle this new service that is coming online.

03:54.180 --> 03:59.490
Right now, we do not have any real bulk kind of endpoint where we can say, give me all the posts for

03:59.490 --> 04:00.720
all eternity per se.

04:00.750 --> 04:04.800
Well, okay, technically our application does right now, but you can imagine that in a production

04:04.800 --> 04:09.870
application we would probably not have an endpoint that just says give me all posts that exist, probably

04:09.870 --> 04:11.430
would not implement something like that.

04:12.770 --> 04:16.460
So if we did not already have some end point like that, we would have to implement it for both posts

04:16.460 --> 04:17.510
and comments.

04:18.410 --> 04:23.480
Now, one thing to be clear about, after getting all the posts and comments and synchronizing all this

04:23.480 --> 04:29.270
data, then from that point in time into the future, then the query service would start to receive

04:29.270 --> 04:31.850
any events that are emitted from posts and comments.

04:31.850 --> 04:35.270
So eventually query would kind of revert back to our expected behavior.

04:35.270 --> 04:39.740
But just to get it online and up and running, it could make these initial synchronous requests.

04:40.220 --> 04:41.360
So that's option number one.

04:42.140 --> 04:47.480
Option number two is the one exception to that rule that we discussed earlier on inside the course around

04:47.480 --> 04:50.090
every service having its own private database.

04:50.740 --> 04:54.190
So it's option number two, which is kind of similar to option number one.

04:54.190 --> 04:59.950
We could say that the instant that query came online, we could give it direct access to the data store

04:59.950 --> 05:02.800
or essentially the database for all the posts that we have.

05:03.040 --> 05:04.630
And same thing for comments as well.

05:04.960 --> 05:09.220
So rather than relying upon synchronous network requests directly to the service, we could just say,

05:09.220 --> 05:11.920
you know what, query needs all the information at a database.

05:11.950 --> 05:13.840
Let's just give it access to the database.

05:14.020 --> 05:18.880
Now, the upside to this is now the query service could run its own queries and figure out all the different

05:18.880 --> 05:22.090
data that it needs to get out of the post database and common database.

05:23.480 --> 05:27.260
After synchronizing all this data once again, the query service could start listening to different

05:27.260 --> 05:27.890
events.

05:28.640 --> 05:33.530
The downside to this approach is once again we are making sync requests over, which means we are going

05:33.530 --> 05:39.080
to have to implement some code inside of query to work directly with whatever this database is or this

05:39.080 --> 05:40.040
database is.

05:40.280 --> 05:47.480
Let's imagine that maybe the post data store over here was my SQL and maybe the comments datastore was

05:47.480 --> 05:48.500
MongoDB.

05:48.830 --> 05:54.260
Now all of a sudden we need to write some code inside a query to interface with a MySQL database and

05:54.260 --> 05:55.790
a MongoDB database.

05:55.970 --> 05:58.310
That's a lot of extra code to potentially have to write.

05:58.950 --> 06:03.540
So on to option number three, which as you can guess, is what we are going to be doing.

06:04.820 --> 06:05.270
All right.

06:05.270 --> 06:10.340
So option number three really falls into the same category that we've gone through several times in

06:10.340 --> 06:14.270
the course where I'm going to tell you this and you're going to say, no way, not possible, totally

06:14.270 --> 06:15.680
inefficient, can't do it.

06:15.680 --> 06:16.580
Not going to happen.

06:16.580 --> 06:21.020
But once again, yes, this is how people actually implement microservices.

06:21.020 --> 06:22.970
People do this, not making this stuff up.

06:23.720 --> 06:25.250
So it's option number three.

06:25.280 --> 06:29.510
We're going to once again say that we are implementing or bringing query online at some point in time

06:29.510 --> 06:30.860
in the future, like right here.

06:32.350 --> 06:38.230
Now in theory, query could work if it had access to all the events that had been emitted in the past.

06:38.740 --> 06:42.850
So the post service, for example, is going to emit events maybe one, two and three, and each of

06:42.850 --> 06:45.010
these might be a post creation event.

06:45.040 --> 06:47.530
Those are all events that Query cares about.

06:47.530 --> 06:49.930
If Query just had access to those events.

06:49.960 --> 06:54.130
It could work just fine, and that's what the strategy is going to rely upon.

06:54.430 --> 07:01.210
We're going to say that whenever any of our services emits any event whatsoever over to the event bus,

07:01.540 --> 07:06.400
the event bus will send that event out to all the other services, but it's going to do something else

07:06.400 --> 07:07.390
at the same time.

07:07.390 --> 07:10.210
It's going to store that event internally.

07:12.140 --> 07:17.180
So we can imagine that after event one gets emitted, the event bus is going to store that event internally

07:17.180 --> 07:18.830
in some kind of data structure.

07:18.890 --> 07:23.840
Probably not in memory, probably in some kind of database or something similar because this data store

07:23.840 --> 07:26.840
is going to grow to be very, very large over time.

07:27.730 --> 07:31.930
We can then imagine that maybe the post service event number two.

07:33.260 --> 07:38.510
And so we would add that on now Event Bus has a record of event one and Event two.

07:38.780 --> 07:41.090
And then finally Event three as well.

07:41.150 --> 07:43.370
And so we can imagine that at that point in time.

07:44.870 --> 07:48.080
The event bus now knows about event one, two and three.

07:48.290 --> 07:53.180
Again, I want to repeat, these events are still going out to all the other services as they currently

07:53.180 --> 07:53.360
are.

07:53.390 --> 07:55.730
We are just adding in one extra little step here.

07:55.820 --> 07:58.250
The event bus is going to store all these events.

07:59.030 --> 08:04.130
Now the upside to this approach is that if query comes along or online at some point in time, the future

08:04.160 --> 08:10.080
where you can say over to the event bus, hey, give me access to all the events you have stored, all

08:10.080 --> 08:10.370
of them.

08:10.370 --> 08:13.580
Just throw them over and I'll decide whether or not I care about them.

08:13.760 --> 08:17.210
And so we can send over event one and event two.

08:18.250 --> 08:19.690
And Event three.

08:20.470 --> 08:25.570
And now the query service will be totally up to speed and we can use all the same code that we've probably

08:25.570 --> 08:30.460
already written to handle these exact events so we don't have to write any extra code.

08:30.790 --> 08:36.940
The only extra burden we really have here is storing all these events inside of our event bus data store.

08:37.090 --> 08:41.620
Now, admittedly, this data store could grow to be extremely large over time.

08:41.860 --> 08:46.120
But as you saw from that calculation we did a little bit ago where we said, hey, we could pay like

08:46.120 --> 08:48.980
$15 a month for 100 million products.

08:49.000 --> 08:54.400
Well, even though it might cost some amount of money, it probably costs way less than you might think.

08:55.100 --> 08:56.810
So that's what we're going to do inside this course.

08:56.810 --> 08:58.690
We are going to be using option number three.

08:58.700 --> 09:04.250
We're going to say that whenever we emit an event, we're going to store it with our event bus so that

09:04.250 --> 09:09.170
if we ever bring a service online in the future, we can get access to all those events that occurred

09:09.170 --> 09:09.950
in the past.

09:11.580 --> 09:15.450
This also solves the issue with a service going down for some point in time.

09:15.900 --> 09:19.800
Let's imagine I don't have a diagram prepared for this, but I'll just improvise really quick.

09:21.110 --> 09:23.300
So let's imagine that.

09:24.170 --> 09:28.760
Moderation misses out on events two and three, but it did receive event one.

09:28.940 --> 09:33.770
When moderation comes back online right here, it can take a look at what the last event was that it

09:33.770 --> 09:34.450
received.

09:34.460 --> 09:39.050
Maybe moderation would know that it had received event one and it could say to the event bus, Hey,

09:39.050 --> 09:40.700
give me all the events.

09:41.800 --> 09:45.520
Give me everything that occurred during the time that I was down.

09:47.000 --> 09:52.940
And so Event Bus can say, okay, you received event one, we'll give you everything since then so we

09:52.940 --> 09:54.320
can take event to.

09:55.520 --> 09:57.880
Throw it over to moderation and event three.

09:57.890 --> 09:58.850
Throw it over.

09:58.850 --> 09:59.270
And now.

09:59.300 --> 10:00.900
Moderation is all caught up.

10:00.920 --> 10:04.940
It's received two events, two in three, even though it was down for some period of time.

10:05.900 --> 10:08.990
So you can see that this approach actually ends up working out pretty well.

10:08.990 --> 10:13.070
Not only does it solve the issue of bringing services online in the future, but it also solves this

10:13.070 --> 10:18.110
problem of events possibly being missed while a service is experiencing some amount of downtime.

10:19.050 --> 10:19.470
All right.

10:19.470 --> 10:20.970
So let's take a pause right here.

10:21.000 --> 10:22.440
I apologize for the long video.

10:22.470 --> 10:23.760
We'll continue in just a moment.
