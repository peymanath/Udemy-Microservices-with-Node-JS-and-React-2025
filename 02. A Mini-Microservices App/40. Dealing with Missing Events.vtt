WEBVTT

00:01.030 --> 00:05.560
اپلیکیشن ما الان داره خوب کار می‌کنه، ولی آخر ویدیوی قبلی با یه مشکل کوچیک روبرو شدیم.

00:05.560 --> 00:09.220
شاید این مشکل از اول دوره توی ذهن شما بوده که: اگه یه سرویس برای یه مدت از دسترس خارج بشه چی میشه؟

00:09.220 --> 00:10.230
الان دقیقاً همینو دیدیم.

00:10.240 --> 00:14.350
سرویس moderation از دسترس خارج شد، ما یه کامنت ایجاد کردیم وقتی اون سرویس قطع بود

00:14.680 --> 00:15.850
و حالا اون کامنت تا ابد تو وضعیت pending می‌مونه.

00:15.850 --> 00:21.280
پس سوال اینه که با این وضعیت چی‌کار باید بکنیم؟

00:21.280 --> 00:25.330
بیایم با یه دیاگرام بهتر متوجه بشیم مشکل اصلی دقیقاً چیه.

00:25.630 --> 00:26.950
پس بریم سراغش.

00:27.100 --> 00:30.670
توی این دیاگرام که یه کم هم شاید در نگاه اول گیج‌کننده باشه، ما یه نمودار توالی زمانی داریم.

00:31.460 --> 00:31.790
خب

00:31.790 --> 00:34.300
اینجا زمان شروع اپلیکیشن‌مونه، از بالا به پایین حرکت می‌کنه.

00:34.310 --> 00:36.700
یعنی زمان به صورت عمودی به سمت پایین جریان داره.

00:36.710 --> 00:41.780
توی اپلیکیشن ما، Bus رویدادها (event bus) این خط سبز وسطه.

00:41.780 --> 00:44.240
تمام سرویس‌هایی که توی این نمودار نشون داده شدن، بخش‌هایی هستن که تو اون زمان فعال بودن.

00:45.700 --> 00:49.000
پس فرض می‌کنیم که event bus، post، comments و query همه از ابتدا روشن بودن.

00:49.000 --> 00:53.380
و توی این بازه احتمالاً چندتا رویداد هم ارسال شده.

00:53.770 --> 00:56.350
مثلاً رویداد اول فرستاده شده و با موفقیت به همه سرویس‌ها رسیده.

00:56.380 --> 00:58.180
چون همه اون موقع روشن بودن.

00:58.180 --> 01:02.470
اما حالا فرض کن یه مدتی سرویس moderation قطع بوده (خط قرمز توی نمودار).

01:03.040 --> 01:06.190
در همین مدت، event 2 و 3 ارسال شدن.

01:06.220 --> 01:12.100
اینا با موفقیت به post، comments و query رسیدن، ولی چون moderation خاموش بوده، اون نتونسته دریافتشون کنه.

01:14.920 --> 01:19.690
بعدش ممکنه moderation دوباره روشن بشه و event 4 رو بگیره.

01:19.690 --> 01:21.550
ولی دیگه event 2 و 3 برای همیشه از دست رفته‌ن.

01:22.120 --> 01:27.880
الان دیگه هیچ راهی نداریم که به moderation بگیم: این دوتا رویداد قبلاً اتفاق افتادن، پس لطفاً اونا رو هم پردازش کن.

01:27.880 --> 01:33.670
این فقط یکی از سناریوهاییه که توش یه سرویس برای یه مدت خاموش میشه.

01:34.390 --> 01:39.250
ولی یه سناریوی دیگه هم هست که شاید از اول دوره تو ذهنت بوده:

01:39.490 --> 01:41.950
اگه ما از اول یه سرویسی نداشته باشیم چی؟

01:41.950 --> 01:46.390
یعنی یه سرویسی مثل query رو اصلاً از ابتدا نسازیم و بعداً تصمیم بگیریم که بسازیم.

01:48.200 --> 01:51.620
مثلاً فرض کن تا ماه‌ها یا حتی سال‌ها فقط post، comments و moderation فعال بودن.

01:51.620 --> 01:56.330
همه اینا کلی رویداد دریافت کردن، کلی دیتا ساختن و زندگی‌شونو کردن!

01:56.330 --> 02:02.990
بعد شاید یک سال بعد تازه بیایم سرویس query رو بسازیم.

02:02.990 --> 02:07.040
و حالا سؤال اینجاست: این سرویس جدید چطوری می‌تونه همه اون اطلاعات قبلی رو بگیره؟

02:07.040 --> 02:11.750
چون اون همه دیتا و event رو از دست داده، و هیچ راهی برای گرفتنشون نداره.

02:11.900 --> 02:17.390
بنابراین ساختن یه سرویس جدید تو این ساختار event-driven بدون فکر به replay یا sync واقعاً یه چالش جدیه.

02:17.390 --> 02:22.340
و الان وقتشه که برای این مشکلات یه راهکار حرفه‌ای و مهندسی پیدا کنیم.

02:24.920 --> 02:29.090
وقتی سرویس query تازه ساخته می‌شه، همه اون رویدادهای قبلی رو از دست داده. پس چطوری می‌تونیم همگام‌سازیش کنیم؟

02:29.090 --> 02:31.490
چطوری همه پست‌ها، کامنت‌ها و وضعیت بررسی‌ها رو به query منتقل کنیم؟

02:31.520 --> 02:36.950
مثل همیشه، چند روش مختلف برای حل این مسئله وجود داره. بیایم چند راهکار ممکن رو بررسی کنیم.

02:37.750 --> 02:41.290
خب این گزینه اول ماست.

02:41.290 --> 02:43.510
فرض می‌کنیم سرویس‌های post و comment از ابتدا در حال اجرا بودن

02:45.090 --> 02:46.410
و بعد مثلاً یک سال بعد سرویس query رو ایجاد کردیم.

02:46.680 --> 02:50.880
طبیعتاً سرویس query باید همه پست‌ها و کامنت‌های موجود رو بدونه.

02:50.880 --> 02:53.130
پس باید somehow با بقیه سینک بشه.

02:53.430 --> 02:57.240
روش اول اینه که از درخواست‌های هم‌زمان (synchronous) استفاده کنیم.

02:57.510 --> 03:02.610
یعنی درست وقتی که سرویس query راه‌اندازی شد، یه کد بذاریم که از طریق درخواست شبکه مستقیم، از سرویس post بخواد که لیست تمام پست‌ها رو بده.

03:02.610 --> 03:06.090
با این روش، می‌تونه همه پست‌های موجود رو با یک درخواست ساده بگیره.

03:06.800 --> 03:10.880
بعدش می‌تونه به سراغ سرویس comment بره و از اونم همین درخواست رو بفرسته: همه کامنت‌هات رو بده.

03:11.450 --> 03:16.880
سپس همه این کامنت‌ها رو با پست‌های مرتبط‌شون توی سرویس query ذخیره کنه.

03:16.880 --> 03:21.590
مشکل این روش واضحه: داریم برمی‌گردیم به مدل هم‌زمان یا synchronous.

03:21.860 --> 03:26.720
یعنی برای راه‌اندازی سرویس جدید باید تو سرویس‌های post و comment یه endpoint پیاده‌سازی کنیم که مثلاً همه پست‌ها یا همه کامنت‌ها رو برگردونه.

03:27.580 --> 03:31.960
در حال حاضر چنین چیزی تو برنامه‌مون هست، ولی تو محیط production احتمالاً چنین endpointی نخواهیم داشت.

03:31.960 --> 03:35.260
چون منطقی نیست که یه API داشته باشیم که همه داده‌های تاریخچه رو بدون محدودیت برگردونه.

03:35.650 --> 03:38.530
پس اگه چنین چیزی نداشتیم، باید مخصوص این نیاز پیاده‌سازیش کنیم.

03:39.390 --> 03:42.270
البته وقتی همه داده‌ها رو گرفتیم و سینک کردیم،

03:42.270 --> 03:44.370
از اون لحظه به بعد، سرویس query می‌تونه بقیه رویدادهای جدید رو به صورت عادی دریافت کنه.

03:44.760 --> 03:50.130
پس در واقع فقط برای راه‌اندازی اولیه لازمه این کار رو بکنه و بعدش برمی‌گرده به رفتار استانداردش.

03:50.130 --> 03:53.640
این شد گزینه اول.

03:54.180 --> 03:59.490
اما گزینه دوم، یه استثناست نسبت به قانونی که قبلاً تو دوره گفتیم مبنی بر اینکه هر سرویس باید دیتابیس خصوصی خودش رو داشته باشه.

03:59.490 --> 04:00.720
توی این روش دوم...

04:00.750 --> 04:04.800
باز هم شبیه گزینه اوله ولی با یه تفاوت مهم.

04:04.800 --> 04:09.870
می‌تونیم بگیم وقتی سرویس query تازه بالا اومد، دسترسی مستقیم به دیتابیس پست‌ها بهش بدیم.

04:09.870 --> 04:11.430
یعنی مستقیماً به storage داده‌های post.

04:12.770 --> 04:16.460
با این کار، query بدون نیاز به API می‌تونه خودش اطلاعات رو از دیتابیس بخونه.

04:16.460 --> 04:23.480
یعنی به جای اینکه از post درخواست بفرسته و post براش پاسخ بده، خودش می‌ره سراغ دیتای post.

04:23.480 --> 04:29.270
این راه سریع‌تره ولی وابستگی ایجاد می‌کنه و نقض اصل انزوا (isolation) بین سرویس‌هاست.

04:29.270 --> 04:31.850
و حالا بریم ببینیم این روش چقدر ارزش داره که انجامش بدیم.

05:03.040 --> 05:04.630
همین قضیه برای کامنت‌ها هم صدق می‌کنه.

05:04.960 --> 05:09.220
یعنی به‌جای اینکه به درخواست‌های هم‌زمان از طریق شبکه تکیه کنیم، می‌تونیم بگیم:

05:09.220 --> 05:11.920
سرویس query به کل دیتا نیاز داره، پس بیایم دسترسی مستقیم به دیتابیس بهش بدیم.

05:11.950 --> 05:13.840
بذاریم خودش مستقیماً دیتا رو بخونه.

05:14.020 --> 05:18.880
مزیت این روش اینه که سرویس query می‌تونه خودش مستقیماً کوئری بزنه و هر دیتایی که نیاز داره رو از دیتابیس post و comment بخونه.

05:18.880 --> 05:22.090
بعد از سینک شدن اطلاعات، می‌تونه دوباره رویدادها رو از طریق event bus گوش بده.

05:23.480 --> 05:27.260
ولی نقطه‌ضعف این روش هم اینه که باز داریم وارد مدل هم‌زمان (sync) می‌شیم.

05:27.260 --> 05:27.890
یعنی چی؟

05:28.640 --> 05:33.530
یعنی باید توی سرویس query کدی بنویسیم که مستقیماً با دیتابیس‌های post و comment کار کنه.

05:33.530 --> 05:39.080
حالا فرض کن post با MySQL نوشته شده، ولی comment از MongoDB استفاده می‌کنه.

05:39.080 --> 05:40.040
چی میشه؟

05:40.280 --> 05:47.480
یعنی query باید بتونه هم به MySQL وصل شه، هم به MongoDB — و این یعنی کلی کد اضافه برای مدیریت این اتصال‌ها.

05:47.480 --> 05:48.500
هزینه زیاد داره.

05:48.830 --> 05:54.260
پس بریم سراغ گزینه سوم — همون گزینه‌ای که قراره ما هم انجامش بدیم.

05:54.260 --> 05:55.790
آماده‌ای؟

05:55.970 --> 05:58.310
گزینه سوم همون کاریه که ممکنه اولش بگی: امکان نداره، خیلی ناکارآمده، اصلاً قابل اجرا نیست.

05:58.950 --> 06:03.540
ولی باید بدونی واقعاً این روش در دنیای واقعی استفاده می‌شه، کاملاً رایجه، دارم از خودم در نمی‌آرم!

06:04.820 --> 06:05.270
بریم ببینیم چی هست.

06:05.270 --> 06:10.340
فرض کنیم که ما سرویس query رو یه زمانی در آینده راه‌اندازی می‌کنیم، مثلاً این نقطه توی نمودار.

06:10.340 --> 06:14.270
تئوریکاً، اگه query به همه رویدادهایی که قبلاً emit شدن دسترسی داشت، می‌تونست کاملاً درست کار کنه.

06:14.270 --> 06:15.680
یعنی چی؟

06:15.680 --> 06:16.580
مثلاً...

06:16.580 --> 06:21.020
سرویس post رویدادهایی مثل event 1، 2، و 3 رو ارسال کرده که همه مثلاً مربوط به ایجاد پست هستن.

06:21.020 --> 06:22.970
Query به اینا نیاز داره.

06:23.720 --> 06:25.250
اگه به اون رویدادها دسترسی داشت، کارش راه می‌افتاد.

06:25.280 --> 06:29.510
پس استراتژی ما هم دقیقاً همینه: کاری کنیم که query به این eventهای قدیمی دسترسی داشته باشه.

06:29.510 --> 06:30.860
چطور؟

06:32.350 --> 06:38.230
می‌گیم هر وقت یه سرویسی هر نوع رویدادی رو منتشر کرد، event bus اون رویداد رو علاوه بر فرستادن به بقیه سرویس‌ها...

06:38.740 --> 06:42.850
یه کار دیگه هم انجام بده: اون رویداد رو داخل خودش ذخیره کنه.

06:42.850 --> 06:54.130
یعنی هم forward کنه، هم persist کنه — اینطوری می‌تونیم بعداً هر سرویس جدیدی مثل query رو بیاریم بالا و replay کنیم همه‌ی رویدادها رو براش.

07:12.140 --> 07:17.180
پس می‌تونیم فرض کنیم که بعد از اینکه Event 1 منتشر شد، Event Bus اون رویداد رو داخل یه ساختار داده‌ای ذخیره می‌کنه.

07:17.180 --> 07:18.830
احتمالاً نه در حافظه، بلکه در یه دیتابیس یا یه سیستم مشابه،

07:18.890 --> 07:23.840
چون این دیتاستور به مرور زمان خیلی بزرگ می‌شه و نمی‌تونیم فقط به RAM تکیه کنیم.

07:23.840 --> 07:26.840
بعدش مثلاً Event 2 هم از سمت post منتشر می‌شه.

07:27.730 --> 07:31.930
و Event Bus هم اونو ذخیره می‌کنه. حالا یه رکورد از Event 1 و Event 2 داره.

07:33.260 --> 07:38.510
در نهایت Event 3 هم اضافه می‌شه. پس الان Event Bus هر سه رو داره.

07:38.780 --> 07:41.090
و ما فرض می‌کنیم که تا این لحظه همه اینا ذخیره شدن.

07:41.150 --> 07:43.370
پس Event Bus الان می‌دونه Event 1، 2 و 3 چی بودن.

07:44.870 --> 07:48.080
تأکید می‌کنم، این رویدادها هنوز همزمان به سرویس‌های دیگه ارسال می‌شن، مثل قبل.

07:48.290 --> 07:53.180
ما فقط یه مرحله اضافی اضافه کردیم: ذخیره‌سازی رویدادها در Event Bus.

07:53.390 --> 07:55.730
فقط همین، هیچ چیزی از قبل خراب نمی‌شه.

07:55.820 --> 07:58.250
فقط داریم این Eventها رو ذخیره می‌کنیم.

07:59.030 --> 08:04.130
مزیت این روش چیه؟ اگه سرویس query بعداً آنلاین شد، می‌تونه به Event Bus بگه:

08:04.160 --> 08:10.080
«همه رویدادهایی که ذخیره کردی رو بده به من، خودم تشخیص می‌دم کدوما برام مهمه».

08:10.080 --> 08:10.370
همه‌شو بده.

08:10.370 --> 08:13.580
اون موقع Event 1 و Event 2 و Event 3 هم براش فرستاده می‌شن.

08:13.760 --> 08:17.210
و حالا سرویس query کاملاً با بقیه همگام شده.

08:18.250 --> 08:19.690
و می‌تونه با همون کدی که قبلاً داشتیم، این رویدادها رو پردازش کنه.

08:20.470 --> 08:25.570
پس دیگه لازم نیست هیچ کد جدیدی بنویسیم — فقط از Eventهای قدیمی استفاده می‌کنیم.

08:25.570 --> 08:30.460
تنها مسئولیت اضافه‌ای که داریم اینه که این Eventها رو توی Event Bus ذخیره کنیم.

08:30.790 --> 08:36.940
درسته که این دیتاستور ممکنه با گذشت زمان خیلی بزرگ بشه، ولی قبلاً هم محاسبه کردیم که می‌تونیم با ۱۵ دلار در ماه ۱۰۰ میلیون آیتم ذخیره کنیم.

08:37.090 --> 08:41.620
یعنی حتی اگه هزینه‌بر باشه، اون‌قدری که فکر می‌کنید گرون نیست.

08:41.860 --> 08:46.120
پس این همون چیزیه که قراره توی این دوره انجام بدیم.

08:46.120 --> 08:48.980
ما از گزینه سوم استفاده می‌کنیم.

08:49.000 --> 08:54.400
هر وقت رویدادی منتشر شد، اون رو با Event Bus ذخیره می‌کنیم تا بعداً اگه سرویسی مثل query بالا اومد...

08:55.100 --> 08:56.810
بتونه همه رویدادهای قبلی رو دریافت کنه.

08:56.810 --> 08:58.690
و کاملاً با بقیه هماهنگ بشه.

08:58.700 --> 09:04.250
این روش، مشکل قطع شدن یک سرویس برای مدتی کوتاه رو هم حل می‌کنه.

09:04.250 --> 09:09.170
مثلاً فرض کنیم سرویس moderation فقط Event 1 رو گرفته ولی Event 2 و 3 رو از دست داده.

09:09.170 --> 09:09.950
چی میشه؟

09:11.580 --> 09:15.450
وقتی moderation دوباره بالا بیاد، می‌تونه چک کنه آخرین Eventی که دریافت کرده چی بوده.

09:15.900 --> 09:19.800
مثلاً اگه فقط Event 1 رو گرفته، می‌تونه به Event Bus بگه:

09:21.110 --> 09:23.300
«همه رویدادهایی که از اون موقع تا حالا منتشر شده رو بده بهم».

09:24.170 --> 09:28.760
یعنی از Event 2 به بعد — و اینطوری می‌تونه اون فاصله‌ای که پایین بوده رو جبران کنه.

09:47.000 --> 09:52.940
پس Event Bus می‌تونه بگه: خب، تو Event 1 رو دریافت کردی، پس از اون به بعد هرچی بوده رو می‌فرستم برات.

09:52.940 --> 09:54.320
یعنی Event 2...

09:55.520 --> 09:57.880
می‌فرستیمش برای moderation، و بعد Event 3...

09:57.890 --> 09:58.850
اونم می‌فرستیم.

09:58.850 --> 09:59.270
و حالا...

09:59.300 --> 10:00.900
moderation هم کامل به‌روز شده.

10:00.920 --> 10:04.940
حتی با اینکه یه مدتی خاموش بوده، حالا Event 2 و 3 رو هم گرفته.

10:05.900 --> 10:08.990
می‌بینی که این روش چقدر خوب جواب می‌ده.

10:08.990 --> 10:13.070
نه‌تنها مشکل راه‌اندازی سرویس جدید رو حل می‌کنه، بلکه جلوی از دست رفتن رویدادها رو هم می‌گیره،

10:13.070 --> 10:18.110
مخصوصاً وقتی که یه سرویس برای مدتی داون باشه.

10:19.050 --> 10:19.470
خب

10:19.470 --> 10:20.970
پس همین‌جا یه مکث می‌کنیم.

10:21.000 --> 10:22.440
ببخشید اگه ویدیو طولانی شد.

10:22.470 --> 10:23.760
الان یه لحظه استراحت می‌کنیم و بعد ادامه می‌دیم.
