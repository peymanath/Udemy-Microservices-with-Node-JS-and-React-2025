WEBVTT

00:01.610 --> 00:05.480
ما تا الان دوبار سبک ارتباط asynchronous رو بررسی کردیم.

00:05.480 --> 00:08.110
و احتمالاً الآن یه سری سوال جدی توی ذهنت شکل گرفته.

00:08.140 --> 00:12.380
توی این ویدیو می‌خوام برم سراغ چندتا از اون سوال‌هایی که احتمالاً توی ذهنت هست و جوابشون رو باهات مرور کنم.

00:12.770 --> 00:16.070
اولین سوالی که ممکنه داشته باشی اینه: «صبر کن ببینم، استیون...

00:16.070 --> 00:21.650
تو داری می‌گی اگه دوتا نوع منبع داده داریم — مثل post و comment — برای اینکه اطلاعاتشون رو به‌درستی نشون بدیم،

00:21.650 --> 00:25.370
باید یه سرویس سوم بسازیم؟»

00:25.670 --> 00:28.100
نه، اصلاً منظورم این نبود.

00:28.250 --> 00:33.950
ما قرار نیست برای هر بار ترکیب داده‌ها یه سرویس جدید بسازیم.

00:34.280 --> 00:40.070
واقعیتش اینه که اگه واقعاً داشتیم یه اپلیکیشن بلاگ می‌ساختیم، این بلاگ بخشی از یه اپلیکیشن بزرگ‌تر بود.

00:40.070 --> 00:44.520
تو اون حالت، احتمالاً پست و کامنت رو داخل یه سرویس واحد قرار می‌دادیم

00:44.540 --> 00:49.730
و اون داده‌ها رو توی کدها با هم join می‌کردیم، نه اینکه برای join کردنشون یه سرویس جدید درست کنیم.

00:49.730 --> 00:54.860
پس کاری که الان انجام می‌دیم صرفاً برای اهداف آموزشی هست.

00:54.860 --> 00:55.520
فقط برای یادگیریه.

00:55.790 --> 00:58.790
هدف اینه که با این ایده آشنا بشی که داده‌ها می‌تونن توی چند سرویس مجزا ذخیره بشن

00:58.790 --> 01:04.850
و بعد بتونی اون داده‌ها رو به‌صورت متمرکز استفاده کنی یا تکرارشون کنی.

01:04.850 --> 01:09.590
پس اصلاً توصیه نمی‌کنم که برای هر join کوچیکی بری یه سرویس جدید راه بندازی.

01:09.590 --> 01:15.200
این فقط یه مدل آموزشی برای درک مفاهیم هست، نه یه معماری توصیه‌شده.

01:16.680 --> 01:18.120
سوال مهم بعدی که ممکنه داشته باشی:

01:18.240 --> 01:22.800
من بارها گفتم این سرویس‌ها مستقل هستن و اگه یکی crash کنه، بقیه هنوز پابرجان.

01:22.800 --> 01:23.430
ممکنه بگی: خب که چی؟

01:23.810 --> 01:25.220
مگه چند وقت یه بار ممکنه سرویس crash کنه؟

01:25.230 --> 01:27.420
مگه اصلاً این اتفاق می‌افته؟

01:27.900 --> 01:32.280
راستش توی این بخش از دوره هنوز خیلی وارد دلایل اصلی استفاده از microservice نشدیم.

01:32.280 --> 01:34.010
ولی صادقانه بگم،

01:34.020 --> 01:37.920
فرض من اینه که تو قبل از شرکت توی این دوره یه تحقیقی در مورد میکروسرویس‌ها کردی

01:37.920 --> 01:43.380
و یه درکی از اینکه چرا می‌خوای ازش استفاده کنی داری.

01:44.010 --> 01:49.500
یکی از دلایل اصلی استفاده از معماری میکروسرویس افزایش قابلیت اطمینان (Reliability) سیستمه.

01:49.500 --> 01:50.420
و این خیلی مهمه.

01:50.430 --> 01:54.690
این‌که ما می‌تونیم سرویس‌ها رو مستقل از هم نگه داریم

01:54.960 --> 01:59.910
و حتی اگه یه بخش سیستم از کار بیفته، بقیه همچنان درست کار کنن،

01:59.910 --> 02:02.130
دلیل خیلی مهمیه برای اینکه چرا سراغ میکروسرویس می‌ریم.

02:02.130 --> 02:07.380
و در واقع همین ویژگی یکی از محرک‌های اصلیه که باعث شده داریم این دوره رو می‌گذرونیم.

02:08.640 --> 02:10.420
سومین چیزی که ممکنه بگی اینه:

02:10.460 --> 02:14.760
«خب، این معماری خیلی پیچیده‌ست برای اون سود کمی که ازش می‌گیریم!»

02:15.520 --> 02:20.040
«داریم پروژه‌های کامل و جدا راه‌اندازی می‌کنیم فقط برای اینکه بتونیم چندتا کوئری ساده روی دیتا بزنیم!»

02:20.520 --> 02:22.010
و بله، الان ممکنه اینطوری به‌نظر بیاد.

02:22.020 --> 02:28.410
می‌دونم این معماری مبتنی بر event ممکنه پیچیده و سخت به نظر برسه، ولی واقعاً فقط در این مرحله‌ی اول اینطوره.

02:28.410 --> 02:30.420
الان همه چیز پیچیده به نظر می‌رسه، ولی...

02:30.690 --> 02:34.910
خیلی زود قراره یه ویژگی جدید به همین پروژه اضافه کنیم،

02:34.920 --> 02:36.570
همین پروژه‌ای که الان داریم روش کار می‌کنیم.

02:37.350 --> 02:41.880
و به‌خاطر اینکه الان از این معماری event-based استفاده کردیم، اضافه کردن اون ویژگی جدید

02:41.880 --> 02:48.750
واقعاً ساده‌تر از حالتیه که با معماری monolith یا ارتباط synchronous بخوایم اون ویژگی رو اضافه کنیم.

02:48.750 --> 02:50.070
پس درسته، الان ممکنه اغراق‌آمیز به نظر بیاد،

02:50.250 --> 02:54.270
ولی در آینده همه‌چی راحت‌تر می‌شه و دلیل این انتخاب رو بهتر درک می‌کنی.

02:54.270 --> 02:56.250
کمی صبر و پیش‌روی لازم داره.

02:58.010 --> 03:01.970
آخرین چیزی که می‌خوام بگم اینه که اگه الان داری واقعاً به این معماری فکر می‌کنی،

03:01.970 --> 03:04.940
شاید بگی: «استیون، یه لحظه صبر کن! این سیستم فقط تو این سناریو جواب می‌ده...»

03:04.970 --> 03:06.950
«اگه فلان event بیفته چی؟ یا اون یکی event؟»

03:06.950 --> 03:09.950
«اگه فلان حالت خاص رخ بده چی؟ یا اون گوشه‌ی خاص چطور؟»

03:09.950 --> 03:11.960
بذار شفاف بگم:

03:12.440 --> 03:17.690
ما قطعاً یه‌سری حالت خاص داریم که باید نگرانشون باشیم و باید حساب‌شده باهاشون برخورد کنیم.

03:17.690 --> 03:19.610
وقتی از این معماری event-based استفاده می‌کنیم،

03:19.610 --> 03:24.830
باید یه نگاه عمیق به بعضی از این سناریوها داشته باشیم و من قول می‌دم که این کار رو توی ادامه‌ی دوره انجام بدیم.

03:24.830 --> 03:29.090
یعنی به‌صورت جدی بعضی از این مشکلات و گوشه‌موشه‌ها رو بررسی می‌کنیم.

03:29.090 --> 03:32.390
و اگه الآن چیزی به نظرت عجیب نمیاد، اشکالی نداره.

03:32.510 --> 03:35.990
این چیزیه که باید مدت طولانی روش فکر کنی تا بتونی بفهمی کجاها ممکنه سیستم دچار مشکل بشه.

03:35.990 --> 03:38.270
و اگر هم الآن متوجه یه ایراد خاص شدی، نگران نباش.

03:38.270 --> 03:41.210
ما به مرور کلی از این حالت‌ها رو بررسی می‌کنیم و براشون راه‌حل داریم.

03:41.210 --> 03:46.730
نمی‌گم برای همه‌چیز راه‌حل کامل داریم، چون شاید تو به چیزهایی فکر کنی که منم هنوز بهش نرسیدم.

03:46.730 --> 03:50.270
ولی توی پروژه‌ی بزرگ‌تری که قراره بعداً روش کار کنیم، اکثر این حالت‌های خاص رو در نظر می‌گیریم.

03:50.270 --> 03:51.890
و واقعاً باهاشون برخورد می‌کنیم.

03:51.890 --> 03:55.820
پس نگران نباش، بهشون می‌رسیم و یاد می‌گیریم چطور کنترل‌شون کنیم.

03:55.820 --> 03:56.990
خب،

03:57.730 --> 03:58.030
تا اینجا همین.

03:58.030 --> 03:58.600
فقط می‌خواستم چندتا سوال مهم و جواب‌هاشون رو مرور کنم که احتمالاً تو ذهنت شکل گرفته بودن.

04:02.110 --> 04:04.780
با در نظر گرفتن همه‌ی این نکاتی که گفتیم، یه توقف کوتاه داشته باشیم.

04:04.810 --> 04:07.460
قراره پیاده‌سازی سرویس جدید کوئری رو شروع کنیم.

04:07.480 --> 04:11.740
قراره Event Bus رو راه‌اندازی کنیم و کاری کنیم که همه‌ی این سرویس‌ها از طریق event با هم ارتباط داشته باشن.

04:11.740 --> 04:13.900
همه‌ی این موارد رو توی ویدیوی بعدی انجام می‌دیم.
