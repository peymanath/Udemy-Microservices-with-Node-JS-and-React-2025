WEBVTT

00:00.840 --> 00:06.960
ما الان داشتیم گزینه دوم رو بررسی می‌کردیم و گفتیم مشکلش اینه که query service خیلی عمیق باید بفهمه معنی event "comment moderated" چیه.

00:06.960 --> 00:10.920
برای حل این موضوع، قراره این event توسط comment service پردازش بشه، نه query service.

00:11.190 --> 00:16.920
اینجوری، مسئولیت دقیق و تخصصی پردازش comment رو می‌سپاریم به سرویسی که خودش اون رو ساخته.

00:17.010 --> 00:19.230
الان بزار نشونت بدم این روش چطوری پیاده‌سازی میشه.

00:24.630 --> 00:29.970
سمت چپ نمودار، comment service رو داریم که تمام منطق بیزینسی مربوط به کامنت‌ها دستشه.

00:29.970 --> 00:35.820
یعنی دقیقاً می‌دونه یک کامنت چیه، چطور باید ساخته یا آپدیت بشه.

00:39.480 --> 00:44.370
پس منطقیه که آپدیت دقیق و درست یک کامنت توسط همین سرویس انجام بشه.

00:44.370 --> 00:47.970
بعد از اینکه این سرویس کامنت رو آپدیت کرد، یک event عمومی ارسال می‌کنه به اسم:

01:00.030 --> 01:01.380
**`comment updated`**

01:01.380 --> 01:13.710
برخلاف eventهای قبلی که مفهوم خاصی داشتن، این یکی خیلی کلیه و فقط می‌گه: «یه نسخه جدید از این کامنت هست، جزئیاتش اینه. هر کی خواست ذخیره‌ش کنه.»

01:13.710 --> 01:18.720
نه نیازه بدونی چرا آپدیت شده، نه لازم تحلیلش کنی. فقط دریافت و ذخیره کن.

01:27.350 --> 01:32.960
پس در کل، هر سرویسی که مسئول یک منبع (resource) خاصه، مسئول آپدیت تخصصی اون هم هست.

01:38.900 --> 01:40.820
و بعدش یک event کلی منتشر می‌کنه.

01:49.430 --> 01:53.210
بیایم ببینیم این پروسه برای کامنت چطوری میشه:

02:04.620 --> 02:10.140
۱. کاربر یک کامنت می‌فرسته → comment service اون رو با status ایجاد می‌کنه → بعد event "comment created" رو می‌فرسته به همه.

02:10.770 --> 02:14.520
اینجوری query service بلافاصله می‌فهمه یک کامنت ساخته شده و می‌تونه اون رو نمایش بده.

02:20.820 --> 02:23.210
مشکلی که تو گزینه یک داشتیم، اینجا حل شده.

02:28.940 --> 02:35.960
۲. moderation service اون کامنت رو بررسی می‌کنه و نتیجه رو با event "comment moderated" فقط به comment service می‌فرسته.


02:37.180 --> 02:43.660
کامنت سرویس تنها جاییه که می‌دونه دقیقاً چطوری باید این آپدیت تخصصی رو روی یک کامنت اعمال کنه.

02:44.050 --> 02:48.700
اینجا مثلاً status رو از "pending" به "approved" تغییر می‌ده.

02:49.770 --> 02:56.310
حالا چون کامنت سرویس یک تغییر تخصصی روی کامنت انجام داده، قراره یک event عمومی منتشر کنه به اسم:

**`comment updated`**

02:56.340 --> 03:01.710
این event خیلی ساده‌ست. فقط می‌گه: یه سری ویژگی‌های این کامنت تغییر کرده. همین.

03:01.710 --> 03:10.920
نه نیاز داری بفهمی چرا، نه اینکه منطق خاصی روش اجرا کنی. اگه لازم داشتی، این ویژگی‌ها رو بردار و ذخیره کن.

03:11.550 --> 03:15.900
این event می‌ره به event bus و از اونجا به query service ارسال میشه.

03:18.840 --> 03:24.320
حالا query service اینجا فقط می‌گه: خب، یه کامنت آپدیت شده. دلیلش مهم نیست، من فقط مقادیر جدید رو برمی‌دارم.

03:30.620 --> 03:32.300
و اطلاعات قبلی رو آپدیت می‌کنم. تموم شد.

03:35.720 --> 03:40.940
ما حتی نمی‌گیم فقط status رو آپدیت کن، کل ویژگی‌ها رو با نسخه جدید جایگزین می‌کنیم.

03:42.270 --> 03:46.620
این تفکیک بین "event تخصصی" و "event عمومی" شاید اول سخت باشه، ولی بعداً توی پروژه‌های بعدی هم تکرار میشه و جا می‌افته.

03:56.490 --> 04:00.740
پس توی اپ ما قراره همین روش رو پیاده‌سازی کنیم: **گزینه سوم**.

04:02.970 --> 04:07.380
یعنی دوتا event خواهیم داشت:  
۱. `comment moderated` → مخصوص بررسی و تأیید یا رد شدن  
۲. `comment updated` → عمومی برای اطلاع‌رسانی هرگونه تغییر

04:14.310 --> 04:16.380
کامنت سرویس تغییر رو اعمال می‌کنه و بعدش اون رو به صورت کلی منتشر می‌کنه.

04:20.440 --> 04:25.650
مزیت این کار؟ query service فقط باید `comment updated` رو بشناسه.

04:31.510 --> 04:32.980
مهم نیست آپدیت از چه نوعیه.

04:35.560 --> 04:38.890
فقط می‌فهمه که «یه چیزی توی این کامنت عوض شده» و اطلاعات جدید رو ذخیره می‌کنه.

04:41.110 --> 04:45.700
خب حالا که همه‌چی مشخص شد، یه وقفه کوچیک داشته باشیم و بعدش بریم سراغ پیاده‌سازی این گزینه سوم.