WEBVTT

00:00.940 --> 00:05.800
یه نکته سریع: اگه کل بخش مربوط به اپلیکیشن React رو رد کردی، احتمالاً کدی که از جلسه قبلی دانلود کردی کامل بوده.

00:05.800 --> 00:07.530
اگه این کارو کردی، حتماً یادداشت متنی داخل همون جلسه رو بخون.

00:07.540 --> 00:10.900
باید مطمئن شی که کل پروژه فعلیت رو با محتوای اون فایل zip جایگزین کنی.

00:11.170 --> 00:15.160
ما دو تا تغییر خیلی کوچیک اعمال کردیم؛ در واقع یک تغییر کوچیک توی دو محل مختلف، یکی در سرویس پست و یکی در سرویس کامنت.

00:15.160 --> 00:15.940
مطمئن شو که این آپدیت‌ها رو گرفتی.

00:16.060 --> 00:21.700
بعد از آپدیت فایل‌ها، فراموش نکن که دوباره `npm install` رو توی دایرکتوری‌های post و comment اجرا کنی.

00:31.120 --> 00:31.420
خب،

00:31.420 --> 00:32.530
بریم سر اصل مطلب.

00:33.190 --> 00:37.870
توی ویدیوی قبلی، پروژه React رو تموم کردیم و دیدیم که می‌تونیم همه پست‌هامون و کامنت‌های مربوط بهشون رو ببینیم.

00:37.870 --> 00:41.950
اما یه ایراد اساسی وجود داشت.

00:41.950 --> 00:47.740
اونم اینه که برای هر پستی که لود می‌کنیم، باید یه درخواست جدا به سرویس کامنت‌ها بفرستیم تا کامنت‌های اون پست رو بگیریم.

00:47.750 --> 00:51.070
تو مثال من، سه تا پست دارم و مجبور شدم سه تا درخواست جدا به سرویس کامنت بزنم.

00:51.340 --> 00:55.900
یعنی برای هر پست، یه درخواست جدا برای گرفتن کامنت‌ها ارسال می‌شه.

00:55.900 --> 00:58.630
که این واقعاً غیربهینه و ناکارآمده.

00:59.880 --> 01:02.070
در واقع الان تو همچین وضعیتی هستیم:

01:02.660 --> 01:08.990
یه درخواست GET به `/posts` می‌زنیم که یه آرایه از پست‌ها بهمون می‌ده.

01:09.110 --> 01:12.920
و برای هر کدوم از اون پست‌ها، مجبوریم یه درخواست اضافه هم بفرستیم.

01:13.190 --> 01:16.280
این روش واقعاً، واقعاً ناکارآمده.

01:16.430 --> 01:20.510
فکر می‌کنم ارزشش رو داشته باشه که ببینیم چطور می‌تونیم همه‌ی اینا رو با یه درخواست واحد انجام بدیم.

01:20.510 --> 01:22.160
هدفم اینه که فقط یه درخواست بفرستم،

01:22.370 --> 01:27.860
یه درخواست واحد، که هم پست‌ها رو برگردونه و هم کامنت‌های مربوط به اون پست‌ها رو.

01:27.860 --> 01:30.470
می‌خوام ببینم می‌تونیم این کار رو انجام بدیم یا نه.

01:30.680 --> 01:32.450
بیایم سعی کنیم پیاده‌سازیش کنیم.

01:33.020 --> 01:38.330
حالا اگه با معماری monolith (یکپارچه) کار می‌کردیم، این کار خیلی ساده و مستقیم انجام می‌شد.

01:38.330 --> 01:39.980
هیچ پیچیدگی خاصی نداشت.

01:39.980 --> 01:44.720
مثلاً توی یه monolith، می‌تونستیم بگیم هر وقت یه درخواست GET به `/posts` زدیم

01:44.720 --> 01:49.880
و توی query string نوشتیم `comments=true`، یعنی اینکه سرور بفهمه ما علاوه‌بر پست‌ها،

01:49.880 --> 01:54.860
کامنت‌های مرتبط با اون پست‌ها رو هم می‌خوایم داخل پاسخ قرار بده.

01:54.860 --> 01:57.170
توی معماری monolith این خیلی ساده و مستقیمه.

02:01.750 --> 02:04.190
اما خب، ما داریم از معماری monolith استفاده نمی‌کنیم.

02:04.210 --> 02:06.970
پس چطور می‌تونیم این مشکل رو با معماری فعلی‌مون حل کنیم؟

02:07.000 --> 02:09.130
چطور می‌خوایم این مسئله رو توی ساختار میکروسرویس‌ها حل کنیم؟

02:10.140 --> 02:14.910
الان فقط می‌تونیم درخواست به سرویس پست یا سرویس کامنت بفرستیم، نه هر دو هم‌زمان.

02:14.910 --> 02:18.480
باید یه راه‌حلی برای این مشکل پیدا کنیم.

02:19.090 --> 02:20.260
برای حل این موضوع،

02:20.260 --> 02:24.220
برمی‌گردیم به یکی از بحث‌هایی که قبلاً در موردش صحبت کردیم؛ یعنی سبک‌های مختلف ارتباط بین سرویس‌ها.

02:24.220 --> 02:25.570
یا همون communication.

02:26.050 --> 02:30.220
پس بیایم دو تا راه‌حل ممکن رو بررسی کنیم و مزایا و معایب هر کدوم رو ببینیم.

02:30.220 --> 02:35.230
این راه‌حل‌ها خیلی شبیه همون سبک‌های ارتباط async و sync هستن که قبلاً راجع‌بهش حرف زدیم.

02:35.230 --> 02:36.400
بیایم با مدل synchronous شروع کنیم.

02:36.850 --> 02:40.330
توی این مدل، فرض کنیم همچنان یه درخواست GET به سرویس پست می‌زنیم

02:40.870 --> 02:46.450
و برای اینکه کامنت‌ها هم همراهش بیان، یه کد جدید داخل سرویس پست می‌نویسیم

02:46.450 --> 02:51.210
که خودش به صورت خودکار بره از سرویس کامنت درخواست بفرسته و بگه:

02:51.220 --> 02:57.670
«لطفاً همه کامنت‌هایی که مربوط به این postIdها هستن رو بده»

02:57.670 --> 03:02.200
بعد سرویس کامنت جواب می‌ده و کامنت‌ها رو برمی‌گردونه،

03:03.110 --> 03:06.080
سرویس پست اون کامنت‌ها رو با پست‌ها ترکیب می‌کنه

03:06.500 --> 03:10.850
و همه رو به‌صورت یک‌جا برمی‌گردونه سمت مرورگر کاربر.

03:10.850 --> 03:13.880
این یه راه‌حل مبتنی بر ارتباط synchronous هست.

03:14.510 --> 03:18.800
ولی خب، معایب این روش دقیقاً همون چیزهایی‌ هستن که قبلاً در مورد ارتباط synchronous گفتیم.

03:19.340 --> 03:23.660
درسته که پیاده‌سازی این روش از نظر مفهومی خیلی ساده‌ست،

03:23.660 --> 03:25.730
ولی مشکلات خودش رو هم داره.

03:26.390 --> 03:31.820
اول اینکه این کار باعث ایجاد وابستگی بین سرویس‌ها می‌شه.

03:31.820 --> 03:33.140
یعنی coupling بین سرویس‌ها.

03:34.250 --> 03:37.640
باید این وابستگی جدید رو در معماری اپلیکیشن‌مون در نظر بگیریم.

03:37.670 --> 03:41.480
مثلاً اگه سرویس کامنت برای هر دلیلی داون بشه یا در دسترس نباشه،

03:42.780 --> 03:46.200
اون وقت سرویس پست هم دیگه درست کار نخواهد کرد.

03:46.200 --> 03:50.790
یعنی اگه اون درخواست بین سرویس پست و کامنت fail بشه، کل درخواست از سمت کاربر هم شکست می‌خوره.

03:50.790 --> 03:52.020
نه پست نمایش داده می‌شه نه کامنت.

03:54.110 --> 03:59.120
ضمن اینکه با این روش، یه round-trip جدید بین سرویس‌ها معرفی کردیم.

03:59.120 --> 04:00.050
یعنی یه درخواست رفت و برگشتی اضافه.

04:00.050 --> 04:02.930
و اگه اون درخواست حتی کمی کند باشه،

04:02.930 --> 04:08.840
پاسخ نهایی برای کاربر هم با تأخیر برمی‌گرده.

04:08.850 --> 04:13.560
دقیقاً همون مشکلاتی که قبلاً در مورد ارتباط synchronous صحبت کردیم.

04:13.560 --> 04:16.440
الان اپلیکیشن ما فقط شامل دو سرویس جداست.

04:23.940 --> 04:29.040
ولی اگه شروع کنیم به اضافه کردن سرویس‌های بیشتر و مثلاً گرفتن کامنت‌ها از سرویس کامنت نیازمند درخواست به سرویس‌های دیگه باشه،

04:29.040 --> 04:33.780
اون‌وقت یه ساختار درختی یا بهتر بگیم یه شبکه از درخواست‌ها به‌وجود میاد

04:33.780 --> 04:38.850
که مشکلات قبل رو به‌مراتب شدیدتر و پیچیده‌تر می‌کنه.

04:39.750 --> 04:44.280
پس با اینکه از نظر مفهومی این روش برای من و شما ساده‌ست، از دید مهندسی شاید بهترین انتخاب نباشه.

04:44.280 --> 04:45.480
ممکنه در عمل آسیب‌زننده باشه.

04:46.470 --> 04:50.450
حالا که مدل ارتباط synchronous رو بررسی کردیم، اینجا یه توقف می‌کنیم

04:50.450 --> 04:53.480
و می‌ریم سراغ بررسی راه‌حل دوم که می‌تونیم ازش استفاده کنیم.
