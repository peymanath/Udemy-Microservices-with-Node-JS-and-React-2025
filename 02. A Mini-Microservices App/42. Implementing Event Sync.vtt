WEBVTT

00:01.200 --> 00:05.250
توی این ویدیو می‌خوایم گزینه سوم رو داخل اپلیکیشن‌مون پیاده‌سازی کنیم.

00:05.460 --> 00:08.190
قراره سرویس Query رو متوقف کنیم.

00:08.190 --> 00:12.180
بعد یه تعداد پست و یه سری کامنت ایجاد کنیم.

00:12.210 --> 00:16.110
سپس دوباره سرویس Query رو اجرا می‌کنیم و بررسی می‌کنیم که آیا این سرویس می‌تونه به event bus وصل بشه و ازش درخواست کنه که:

00:16.110 --> 00:17.970
«همه رویدادهایی که تا الان اتفاق افتاده رو بهم بده».

00:17.970 --> 00:20.880
یادت باشه ما داریم یه نسخه ساده‌شده و دست‌ساز از event bus می‌سازیم.

00:21.270 --> 00:25.710
پروژه‌های متن‌باز زیادی هستن که در محیط‌های production به شکل خیلی حرفه‌ای همین کارها رو انجام می‌دن.

00:25.830 --> 00:32.280
اما ما اینجا فقط می‌خوایم درک کنیم که پشت صحنه دقیقاً چه اتفاقی می‌افته، نه اینکه یه سیستم واقعی برای محیط عملیاتی بنویسیم.

00:32.280 --> 00:37.140
پس کدی که اینجا می‌نویسیم نباید توی محیط production استفاده بشه.

00:37.140 --> 00:41.190
هدف فقط اینه که بفهمیم فرآیند چطور پیش می‌ره.

00:41.190 --> 00:41.730
همین و بس.

00:41.760 --> 00:44.850
پس لطفاً از این کد توی پروژه واقعی استفاده نکن.

00:44.850 --> 00:48.060
فقط برای یادگیریه.

00:48.960 --> 00:53.460
اولین کاری که می‌کنیم اینه که وقتی event bus یک رویداد دریافت کرد، اون رو داخل یه آرایه ذخیره کنه.

00:53.460 --> 00:55.320
همه رویدادها رو توی یک آرایه نگه می‌داریم.

00:55.740 --> 01:00.990
سپس یک endpoint جدید به event bus اضافه می‌کنیم تا بتونیم همه‌ی رویدادهای گذشته رو ازش بگیریم.

01:00.990 --> 01:02.670
یعنی یه مسیر جدید برای دریافت کل آرشیو eventها.

01:03.090 --> 01:07.470
بعد مطمئن می‌شیم که وقتی سرویس Query اجرا میشه، بره از event bus تمام رویدادهای قبلی رو بگیره.

01:07.470 --> 01:12.000
و اون‌ها رو پردازش کنه تا بتونه وضعیتش رو با کل سیستم هماهنگ نگه داره.

01:12.000 --> 01:13.530
خب، بریم سراغ پیاده‌سازی.

01:14.300 --> 01:15.110
شروع کنیم.

01:15.110 --> 01:19.130
اولین مرحله اینه که بریم سراغ event bus و مطمئن بشیم که همه‌ی eventهایی که دریافت می‌کنیم رو ذخیره می‌کنیم.

01:22.720 --> 01:26.020
توی ادیتور، می‌رم سراغ پیاده‌سازی event bus.

01:26.020 --> 01:27.490
فایل index.js رو باز می‌کنم.

01:28.600 --> 01:32.140
در بالای handler مربوط به POST که برای دریافت رویدادهاست،

01:32.290 --> 01:39.100
یه متغیر جدید تعریف می‌کنم به اسم events که یک آرایه خالیه.

01:39.280 --> 01:43.180
قراره همه رویدادهایی که دریافت می‌کنیم رو داخل این آرایه بریزیم.

01:44.840 --> 01:46.580
حالا می‌ریم داخل handler مربوط به POST request.

01:47.560 --> 01:51.840
اونجا هر event که دریافت شد، با استفاده از events.push ذخیره‌اش می‌کنیم.

01:51.850 --> 01:55.180
یعنی می‌نویسیم: events.push(event)

01:56.640 --> 02:00.660
در نتیجه، آخرین رویدادی که دریافت کردیم انتهای آرایه قرار می‌گیره.

02:00.690 --> 02:04.140
و اولین رویداد هم در ابتدای آرایه باقی می‌مونه.

02:05.360 --> 02:10.130
حالا قراره یه endpoint جدید توی event bus بسازیم تا بتونیم همه‌ی این رویدادها رو دریافت کنیم.

02:11.270 --> 02:13.730
بعد از اون handler مربوط به POST که قبلاً داشتیم،

02:14.930 --> 02:22.760
یه route جدید تعریف می‌کنم با app.get برای مسیر /events و اگر کسی به این مسیر درخواست بده،

02:22.760 --> 02:27.800
ما کل لیست eventهایی که توی اون آرایه ذخیره کردیم رو براش برمی‌گردونیم.

02:28.780 --> 02:29.530
دوباره یادآوری کنم:

02:29.530 --> 02:31.820
همون‌طور که قبل‌تر هم گفتم،

02:31.840 --> 02:35.990
پیاده‌سازی واقعی یه event bus خیلی پیچیده‌تر از چیزیه که ما الان داریم.

02:36.010 --> 02:41.500
ما فقط می‌خوایم با این ساختار ساده بفهمیم وقتی یه سرویس خاموش میشه و دوباره برمی‌گرده، چطور می‌تونه خودش رو با بقیه هماهنگ کنه.

02:41.500 --> 02:45.400
چه اون سرویس فقط موقتاً قطع شده باشه یا تازه ساخته شده باشه.

02:46.640 --> 02:46.940
خب،

02:46.940 --> 02:49.310
حالا بریم سراغ سرویس query.

02:49.910 --> 02:51.020
فایل event bus رو می‌بندم.

02:51.320 --> 02:54.560
می‌رم سراغ فایل index.js در سرویس query.

02:56.530 --> 03:00.580
اولین کاری که اینجا می‌کنیم اینه که کدی که مربوط به مدیریت eventهاست رو از handler اصلی جدا کنیم.

03:00.580 --> 03:03.040
چون الان تمام منطق مرتبط با هر event

03:03.430 --> 03:08.380
مستقیماً داخل همون handler مربوط به POST نوشته شده، که باعث میشه قابل استفاده در جای دیگه نباشه.

03:08.380 --> 03:12.940
ما قراره از این منطق در جاهای دیگه فایل هم استفاده کنیم، پس بهتره اون رو در قالب یه تابع مجزا دربیاریم.

03:13.150 --> 03:18.160
پس تمام ifهایی که مربوط به بررسی type event هستن رو می‌بُریم و می‌بریم توی یه تابع helper.

03:18.370 --> 03:22.420
توی handler مربوط به POST، می‌رم سراغ اولین if و تا آخرین if رو انتخاب می‌کنم.

03:22.420 --> 03:23.080
همه رو cut می‌کنم.

03:23.990 --> 03:27.470
فقط مقدار type و data و یه console.log باقی می‌مونه.

03:27.890 --> 03:30.590
حالا میام پایین‌تر از route مربوط به POST

03:31.980 --> 03:33.270
و یه تابع جدید تعریف می‌کنم به اسم handleEvent.

03:33.480 --> 03:38.190
و اون کدهایی که cut کرده بودم رو داخل این تابع paste می‌کنم.

03:40.930 --> 04:00.250
این تابع نیاز داره به type و data دسترسی داشته باشه، پس این دوتا رو به عنوان پارامتر بهش می‌دم.

04:00.280 --> 04:05.620
در نهایت توی handler اصلی، اون console.log رو حذف می‌کنم و به جاش تابع handleEvent رو صدا می‌زنم.

04:07.530 --> 04:11.400
و مقادیر type و data رو بهش پاس می‌دم.

04:11.490 --> 04:14.010
یعنی الان منطق پردازش eventها رو ریختیم داخل یه تابع قابل استفاده مجدد.

04:14.800 --> 04:17.600
خیلی خوب.

04:18.690 --> 04:21.660
حالا آخرین کاری که می‌خوایم انجام بدیم اینه که زمانی که سرویس query میاد بالا و شروع می‌کنه به گوش دادن روی پورت 4002،

04:23.010 --> 04:27.030
بلافاصله بعدش، یه درخواست به event bus بفرسته تا تمام رویدادهای قبلی رو دریافت کنه.

04:28.840 --> 04:29.170
خب،

04:29.170 --> 04:35.190
پس بلافاصله بعد از console.log مربوط به شروع سرویس، می‌نویسم:

04:35.200 --> 04:36.440
await axios.get

04:36.460 --> 04:42.490
برای آدرس http://localhost:4005/events

05:04.780 --> 05:07.200
این درخواست به ما تمام eventهایی که تا الان اتفاق افتادن رو می‌ده.

05:07.210 --> 05:09.250
یادت باشه، اینجا داریم یک درخواست GET می‌فرستیم.

05:10.530 --> 05:12.690
نتیجه رو داخل یه متغیر به اسم res ذخیره می‌کنم.

05:13.800 --> 05:17.190
فراموش نکنیم که تابعی که این کد توشه باید async باشه چون داریم از await استفاده می‌کنیم.

05:18.710 --> 05:22.730
در نهایت، روی تمام eventهایی که دریافت کردیم حلقه می‌زنیم، با یک for...of ساده.

05:22.730 --> 05:23.240
می‌تونی از forEach هم استفاده کنی، ولی اینجا ما با for...of پیش می‌ریم چون مستقیم و ساده‌ست.

05:23.240 --> 05:25.820
می‌نویسم: let event of res.data

05:25.820 --> 05:31.340
یادت باشه که وقتی از axios استفاده می‌کنیم، داده اصلی داخل پاسخ در فیلد res.data قرار می‌گیره.

05:32.420 --> 05:37.490
داخل حلقه، اول یه console.log می‌زنیم که مثلاً بنویسه "در حال پردازش event نوع ..."

05:41.370 --> 05:46.410
یعنی بنویسیم: Processing event: و بعدش type اون event رو چاپ کنیم.

05:46.650 --> 05:47.520
برای تست خوبه.

05:49.270 --> 05:50.620
بعد از اون، واقعاً event رو پردازش می‌کنیم.

05:52.530 --> 05:54.960
یعنی تابع handleEvent رو صدا می‌زنیم.

05:54.960 --> 05:56.340
و type و data اون event رو بهش می‌دیم.

05:56.790 --> 06:00.120
handleEvent(event.type, event.data)

06:01.670 --> 06:02.720
و همین.

06:04.430 --> 06:04.700
خب،

06:04.700 --> 06:05.720
کد رو ذخیره می‌کنیم.

06:06.230 --> 06:10.190
این ویدیو کمی طولانی شد، پس یه توقف کوتاه می‌کنیم و بعد بریم تستش کنیم ببینیم جواب می‌ده یا نه.
