WEBVTT

00:01.710 --> 00:06.270
ما گفتیم که ارتباط هم‌زمان (Synchronous) شاید بهترین راه‌حل نباشه،

00:06.270 --> 00:11.340
چون گرچه برای من و تو ساده‌ست، ولی از دید مهندسی خیلی ایده‌آل نیست.

00:11.550 --> 00:14.310
توی این ویدیو می‌خوایم یه راه‌حل دوم رو بررسی کنیم.

00:14.310 --> 00:18.180
همون‌طور که حدس زدی، این بار می‌ریم سراغ ارتباط غیرهم‌زمان (Asynchronous).

00:18.690 --> 00:23.520
تو ارتباط‌های غیرهم‌زمان معمولاً یه چیزی به اسم "Event Broker" معرفی می‌شه.

00:23.670 --> 00:29.910
وظیفه‌ی Event Broker اینه که نوتیفیکیشن‌ها یا رویدادهایی که از سرویس‌های مختلف میان رو بگیره

00:30.390 --> 00:35.610
و اون‌ها رو به سرویس‌های دیگه‌ای که در حال اجرا هستن ارسال کنه.

00:37.190 --> 00:41.390
پس با این رویکرد، قراره رفتار برنامه‌مون به طور جدی تغییر کنه.

00:41.960 --> 00:45.560
قراره یه چیزی به اسم Query Service اضافه کنیم.

00:46.160 --> 00:52.700
وظیفه‌ی این سرویس اینه که هر زمان یه پست یا کامنت ساخته شد، به اون رویداد گوش بده.

00:53.210 --> 00:58.070
یعنی وقتی یه پست یا کامنت ساخته می‌شه، اون سرویس یه Event ارسال می‌کنه.

00:58.930 --> 01:03.460
Query Service اون Event رو دریافت می‌کنه و پست‌ها و کامنت‌ها رو جمع می‌کنه

01:03.460 --> 01:09.310
و اون‌ها رو توی یه ساختار داده‌ای خیلی بهینه ذخیره می‌کنه تا بتونه مشکلی که داریم رو حل کنه،

01:09.310 --> 01:14.230
یعنی این‌که به‌جای چندین درخواست جداگانه، فقط یک درخواست به سمت سرور ارسال بشه.

01:14.230 --> 01:16.300
همه‌چی در یک درخواست خلاصه بشه.

01:16.630 --> 01:21.550
در واقع هدف Query Service اینه که تمام پست‌ها و کامنت‌ها رو جمع کنه

01:21.550 --> 01:25.750
و اون‌ها رو توی یه API ساده و سریع برای مرورگر فراهم کنه.

01:27.360 --> 01:30.030
بیایم ببینیم این توی عمل چطوری کار می‌کنه.

01:30.330 --> 01:32.820
از این‌جا شروع می‌کنیم:

01:33.610 --> 01:38.830
وقتی کسی یه درخواست POST به سرویس پست‌ها می‌فرسته، اون سرویس یه Event ارسال می‌کنه.

01:38.830 --> 01:41.410
مثلاً یه Event به شکل زیر:

01:41.590 --> 01:47.350
type: "PostCreated" با یک سری دیتا مثل id و title اون پست.

01:47.350 --> 01:49.870
دیتای اصلی همون پستیه که ساخته شده.

01:49.870 --> 01:51.820
حالا این Event به Event Bus ارسال می‌شه.

01:52.810 --> 01:56.620
و Event Bus اون رو به تمام سرویس‌هایی که بهش علاقه دارن می‌فرسته.

01:57.420 --> 02:02.310
مثلاً به Query Service هم می‌فرسته.

02:02.310 --> 02:04.560
حالا نوبت Query Service هست که اون Event رو پردازش کنه.

02:04.860 --> 02:07.260
و اطلاعات مربوطه رو یه جایی ذخیره کنه.

02:08.000 --> 02:12.860
مثلاً توی یه ساختار داده‌ای مثل همینی که این‌جا داریم.

02:13.640 --> 02:17.510
یعنی یه آبجکت یا کالکشن که تمام پست‌ها و اطلاعات مربوط بهشون رو نگه می‌داره.

02:17.960 --> 02:22.130
و هر Event جدید که بیاد، اطلاعاتش به این ساختار اضافه میشه.

02:22.130 --> 02:23.480
تا همیشه آپدیت بمونه.

02:29.840 --> 02:30.440
پست‌ها.

02:30.830 --> 02:35.840
ما ممکنه ID هر پست، عنوانش و کامنت‌های مرتبط باهاش رو توی این ساختار ذخیره کنیم.

02:36.350 --> 02:41.270
پس هر وقت یه Event از نوع PostCreated بیاد، ID اون پست رو برمی‌داریم

02:42.390 --> 02:44.130
و یه پست جدید توی ساختارمون اضافه می‌کنیم.

02:44.130 --> 02:48.690
مثلاً ID می‌تونه باشه "ba1JP5" و عنوانش "new post"

02:48.990 --> 02:53.370
و چون هنوز هیچ کامنتی برای این پست نداریم، فیلد کامنت‌ها رو به صورت یه آرایه خالی مقداردهی می‌کنیم

02:53.370 --> 02:58.110
تا بعداً که کامنتی براش میاد، به اون آرایه اضافه بشه.

03:00.410 --> 03:05.480
حالا فرض کنیم یه نفر تو آینده برای همین پست یه کامنت ثبت می‌کنه.

03:05.480 --> 03:06.410
یعنی...

03:07.890 --> 03:12.690
یه درخواست POST به سرویس کامنت فرستاده می‌شه و درست مثل قبل...

03:12.720 --> 03:17.250
سرویس کامنت یه Event منتشر می‌کنه، مثلاً:

03:17.940 --> 03:23.100
type: "CommentCreated" همراه با دیتا مربوط به اون کامنت جدید.

03:23.100 --> 03:23.670
مثل ID و محتواش.

03:24.110 --> 03:28.620
این Event میره به سمت Event Bus و اون هم به همه سرویس‌هایی که علاقه دارن، ارسالش می‌کنه.

03:28.620 --> 03:31.080
یکی از اون سرویس‌ها همون Query Service هست.

03:31.810 --> 03:36.550
حالا دوباره نوبت Query Service هست که این Event جدید رو پردازش کنه.

03:37.920 --> 03:39.780
پس برمی‌گردیم به اون ساختار قبلی.

03:39.930 --> 03:43.980
توی Query Service همون ساختار داده‌ای قبلی رو داریم که پست‌ها داخلش هستن.

03:43.980 --> 03:46.110
مثلاً پست مورد نظر قبلاً ثبت شده.

03:46.710 --> 03:50.250
حالا یه تکه کد می‌نویسیم توی Query Service که اون کامنت جدید رو بگیره

03:51.520 --> 03:53.890
و داخل آرایه‌ی کامنت‌های همون پست بریزه.

03:54.220 --> 03:58.560
پست رو از روی postId پیدا می‌کنیم و کامنت رو بهش اضافه می‌کنیم.

03:58.630 --> 04:01.390
مثلاً postId همون "a1JB5" باشه

04:02.050 --> 04:03.250
و پست موردنظر رو پیدا می‌کنیم.

04:03.820 --> 04:08.710
سپس، این کامنت جدید رو اضافه می‌کنیم به آرایه‌ی کامنت‌های اون پست.

04:09.190 --> 04:16.510
مثلاً: id: "2j56" و content: "اینم یه کامنت جدید"

04:19.100 --> 04:24.800
حالا در این وضعیت، کاربر می‌تونه مستقیماً یه درخواست به Query Service بفرسته

04:24.800 --> 04:27.200
و همه پست‌ها و کامنت‌های مربوط بهشون رو دریافت کنه.

04:27.350 --> 04:32.150
Query Service فقط لازمه کل اون ساختار داده‌ای رو به‌سادگی به مرورگر برگردونه.

04:32.540 --> 04:36.320
و این ساختار همه پست‌ها و کامنت‌ها رو در خودش داره.

04:37.510 --> 04:40.480
این همون سبک ارتباط غیرهم‌زمان (asynchronous) هست.

04:41.670 --> 04:45.900
توی این دیاگرام، فقط می‌خوام کاملاً مشخص باشه که به جای اینکه درخواست به Post Service بفرستیم

04:45.900 --> 04:50.040
برای گرفتن لیست پست‌ها، حالا فقط یه درخواست GET به Query Service می‌فرستیم.

04:50.040 --> 04:51.630
همین.

04:51.960 --> 04:55.350
و البته این یعنی باید یه سری تغییرات توی اپلیکیشن React‌مون بدیم.

04:56.330 --> 04:56.600
تمام.

04:56.600 --> 05:00.140
So at this point, I want to go over some pros and cons of this approach.

05:00.140 --> 05:04.220
And it turns out, yeah, the pros and cons are identical to what we discussed before.

05:04.940 --> 05:09.530
This query service that we're imagining creating doesn't really have any direct dependencies on other

05:09.530 --> 05:10.370
services.

05:10.430 --> 05:12.020
Yes, I totally agree with you.

05:12.020 --> 05:16.790
I understand it does rely upon some incoming events that are being issued by those services.

05:17.000 --> 05:21.350
But if those services go d05:21.350 --> 05:24.380
حتی اگه یکی از سرویس‌ها به هر دلیلی از کار بیفته یا قطع بشه،

05:24.380 --> 05:25.330
Query Service همچنان به کار خودش ادامه می‌ده.

05:25.330 --> 05:29.620
از نظر سرعت هم Query Service خیلی خیلی سریع‌تره نسبت به مدل هم‌زمان قبلی.

05:29.620 --> 05:30.550
و دلیلش واضحه.

05:31.360 --> 05:35.800
چون دیگه هیچ درخواست مستقیمی بین سرویس‌هامون رد و بدل نمی‌شه.

05:35.830 --> 05:39.730
وقتی کاربر لیست پست‌ها و کامنت‌ها رو می‌خواد، فقط یه درخواست ساده می‌فرسته.

05:39.730 --> 05:41.620
همه چی تو همون یه درخواست انجام می‌شه.

05:43.400 --> 05:46.490
اما نقطه‌ضعف‌هاش دقیقاً همون چیزایی‌ان که قبلاً گفتیم.

05:46.490 --> 05:48.350
الان یه مشکلی به اسم تکرار داده داریم.

05:48.770 --> 05:54.410
بذار روشن بگم: حتی تو این مدل غیرهم‌زمان، اگه یه درخواست POST به سرویس پست بیاد،

05:54.410 --> 05:56.870
اون سرویس همچنان پست رو تو دیتای خودش ذخیره می‌کنه.

05:57.380 --> 06:00.260
یعنی سرویس پست تعریف خودش از یه پست رو داره و نگه می‌داره.

06:00.260 --> 06:05.240
اما از طرف دیگه، اطلاعات همون پست داره تو Query Service هم ذخیره میشه.

06:05.240 --> 06:10.460
یعنی الان عملاً داده‌هامون بین این دو تا سرویس تکرار شده.

06:10.460 --> 06:11.120
داده Duplicate شده.

06:11.600 --> 06:15.890
ممکنه در نگاه اول بگی اینکار کلی منابع هدر می‌ده، ولی واقعاً دلایل خوبی برای این تکرار وجود داره.

06:16.340 --> 06:20.990
و اینکه چرا این کار منطقیه، توی ادامه‌ی دوره به طور مفصل بررسی می‌کنیم.

06:20.990 --> 06:25.130
و اما آخرین مشکل این مدلی اینه که—بدون هیچ شکی—فهمیدنش خیلی سخت‌تره.

06:25.130 --> 06:25.550
بدون شک.

06:26.710 --> 06:31.480
از دید مهندسی، پیاده‌سازی این مدل پیچیده‌تره، چون باید از تمام Eventهایی که تو برنامه در حال جریانه باخبر باشیم.

06:31.510 --> 06:32.680
و اونا رو مدیریت کنیم.

06:33.130 --> 06:37.090
وگرنه همه چی خیلی زود بهم می‌ریزه.

06:40.370 --> 06:45.470
با این حال، از نظر عملکرد واقعی و کارایی اجرایی، این مدل واقعاً فوق‌العاده سریعه.

06:45.470 --> 06:46.250
خیلی بهینه‌ست.

06:46.280 --> 06:48.650
هیچ وابستگی‌ای به سرویس‌های دیگه نداره.

06:48.650 --> 06:52.670
پس حتی اگه بقیه سرویس‌ها قطع بشن، این سرویس همچنان به کار خودش ادامه می‌ده.

06:54.610 --> 06:57.490
الان ممکنه با خودت بگی: خب استیون، باشه...

06:57.940 --> 06:58.420
قبوله...

06:58.420 --> 06:59.070
شاید راست می‌گی...

06:59.080 --> 07:00.380
شاید این روش درسته...

07:00.400 --> 07:02.020
ولی یه عالمه سوال تو ذهنم دارم.

07:02.020 --> 07:06.400
برای همین من یه دیاگرام آماده کردم که سوال‌هایی که احتمالاً الان تو ذهنت داری رو آوردم

07:06.400 --> 07:09.070
و جواب‌های احتمالی هم براشون گذاشتم.

07:09.340 --> 07:10.930
البته این ویدیو یکم طولانی شده.

07:10.930 --> 07:14.560
پس همین‌جا یه توقف کوتاه می‌کنیم و تو ویدیوی بعدی می‌ریم سراغ این سوال‌ها و نگرانی‌هایی که ممکنه داشته باشی.